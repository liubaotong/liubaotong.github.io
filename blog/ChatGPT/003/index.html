<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8">
		<meta name="viewport" content="width=device-width">
		<link rel="icon" type="image/svg+xml" href="/favicon.svg">
		<meta name="generator" content="Astro v2.2.1">
		<title></title>
	<link rel="stylesheet" href="/_astro/001.c8750cb8.css" /></head>
	<body>
		<h1 id="c语言实现一个给文件夹加密的程序">C语言实现一个给文件夹加密的程序</h1>
<h2 id="user">user:</h2>
<p>C语言实现一个给文件夹加密的程序</p>
<h2 id="assistant">assistant:</h2>
<p>由于加密文件夹涉及文件的读写，所以需要用到文件操作相关的库函数。下面是一个简单的C语言程序，可以将指定文件夹的所有文件进行加密处理。</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">#include</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#x3C;stdio.h></span></span>
<span class="line"><span style="color: #FF7B72">#include</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#x3C;stdlib.h></span></span>
<span class="line"><span style="color: #FF7B72">#include</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#x3C;string.h></span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">#define</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">KEY</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">"123456"</span><span style="color: #8B949E"> // 密钥</span></span>
<span class="line"><span style="color: #FF7B72">#define</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">BUFFER_SIZE</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1024</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">void</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">encrypt</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">char</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #FFA657">path</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">char</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #FFA657">key</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #C9D1D9">    FILE </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">fp_src, </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">fp_dst;</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">char</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">buffer</span><span style="color: #C9D1D9">[BUFFER_SIZE];</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">size_t</span><span style="color: #C9D1D9"> nread;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// 打开源文件夹</span></span>
<span class="line"><span style="color: #C9D1D9">    fp_src </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">opendir</span><span style="color: #C9D1D9">(path);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (fp_src </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #D2A8FF">fprintf</span><span style="color: #C9D1D9">(stderr, </span><span style="color: #A5D6FF">"Cannot open directory </span><span style="color: #79C0FF">%s\n</span><span style="color: #A5D6FF">"</span><span style="color: #C9D1D9">, path);</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #D2A8FF">exit</span><span style="color: #C9D1D9">(EXIT_FAILURE);</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// 创建目标文件夹</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">char</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">dst_path</span><span style="color: #C9D1D9">[</span><span style="color: #79C0FF">1024</span><span style="color: #C9D1D9">];</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">sprintf</span><span style="color: #C9D1D9">(dst_path, </span><span style="color: #A5D6FF">"</span><span style="color: #79C0FF">%s</span><span style="color: #A5D6FF">_encrypted"</span><span style="color: #C9D1D9">, path);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (</span><span style="color: #D2A8FF">mkdir</span><span style="color: #C9D1D9">(dst_path, </span><span style="color: #FF7B72">0</span><span style="color: #79C0FF">700</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">!=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #D2A8FF">fprintf</span><span style="color: #C9D1D9">(stderr, </span><span style="color: #A5D6FF">"Cannot create directory </span><span style="color: #79C0FF">%s\n</span><span style="color: #A5D6FF">"</span><span style="color: #C9D1D9">, dst_path);</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #D2A8FF">exit</span><span style="color: #C9D1D9">(EXIT_FAILURE);</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// 遍历源文件夹下的所有文件</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">struct</span><span style="color: #C9D1D9"> dirent </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">entry;</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">while</span><span style="color: #C9D1D9"> ((entry </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">readdir</span><span style="color: #C9D1D9">(fp_src))) {</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #8B949E">// 忽略.和..</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (</span><span style="color: #D2A8FF">strcmp</span><span style="color: #C9D1D9">(entry->d_name, </span><span style="color: #A5D6FF">"."</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">||</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">strcmp</span><span style="color: #C9D1D9">(entry->d_name, </span><span style="color: #A5D6FF">".."</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">continue</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #8B949E">// 拼接源路径和目标路径</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">char</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">src_file</span><span style="color: #C9D1D9">[</span><span style="color: #79C0FF">1024</span><span style="color: #C9D1D9">], </span><span style="color: #FFA657">dst_file</span><span style="color: #C9D1D9">[</span><span style="color: #79C0FF">1024</span><span style="color: #C9D1D9">];</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #D2A8FF">sprintf</span><span style="color: #C9D1D9">(src_file, </span><span style="color: #A5D6FF">"</span><span style="color: #79C0FF">%s</span><span style="color: #A5D6FF">/</span><span style="color: #79C0FF">%s</span><span style="color: #A5D6FF">"</span><span style="color: #C9D1D9">, path, entry->d_name);</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #D2A8FF">sprintf</span><span style="color: #C9D1D9">(dst_file, </span><span style="color: #A5D6FF">"</span><span style="color: #79C0FF">%s</span><span style="color: #A5D6FF">/</span><span style="color: #79C0FF">%s</span><span style="color: #A5D6FF">"</span><span style="color: #C9D1D9">, dst_path, entry->d_name);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #8B949E">// 打开源文件</span></span>
<span class="line"><span style="color: #C9D1D9">        fp_src </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">fopen</span><span style="color: #C9D1D9">(src_file, </span><span style="color: #A5D6FF">"rb"</span><span style="color: #C9D1D9">);</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (fp_src </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">continue</span><span style="color: #C9D1D9">;</span><span style="color: #8B949E"> // 打开文件失败，忽略该文件</span></span>
<span class="line"><span style="color: #C9D1D9">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #8B949E">// 创建目标文件</span></span>
<span class="line"><span style="color: #C9D1D9">        fp_dst </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">fopen</span><span style="color: #C9D1D9">(dst_file, </span><span style="color: #A5D6FF">"wb"</span><span style="color: #C9D1D9">);</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (fp_dst </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #D2A8FF">fclose</span><span style="color: #C9D1D9">(fp_src);</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">continue</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #8B949E">// 加密文件内容</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">while</span><span style="color: #C9D1D9"> ((nread </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">fread</span><span style="color: #C9D1D9">(buffer, </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">, BUFFER_SIZE, fp_src)) </span><span style="color: #FF7B72">></span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> (</span><span style="color: #FF7B72">size_t</span><span style="color: #C9D1D9"> i </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">; i </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> nread; i</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">buffer</span><span style="color: #C9D1D9">[i] </span><span style="color: #FF7B72">^=</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">key</span><span style="color: #C9D1D9">[i </span><span style="color: #FF7B72">%</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">strlen</span><span style="color: #C9D1D9">(key)];</span></span>
<span class="line"><span style="color: #C9D1D9">            }</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #D2A8FF">fwrite</span><span style="color: #C9D1D9">(buffer, </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">, nread, fp_dst);</span></span>
<span class="line"><span style="color: #C9D1D9">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #8B949E">// 关闭文件</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #D2A8FF">fclose</span><span style="color: #C9D1D9">(fp_src);</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #D2A8FF">fclose</span><span style="color: #C9D1D9">(fp_dst);</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">closedir</span><span style="color: #C9D1D9">(fp_src);</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">main</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">argc</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">char</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #FFA657">argv</span><span style="color: #FF7B72">[]</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (argc </span><span style="color: #FF7B72">!=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">2</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #D2A8FF">printf</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">"Usage: </span><span style="color: #79C0FF">%s</span><span style="color: #A5D6FF"> &#x3C;path></span><span style="color: #79C0FF">\n</span><span style="color: #A5D6FF">"</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">argv</span><span style="color: #C9D1D9">[</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">]);</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">encrypt</span><span style="color: #C9D1D9">(</span><span style="color: #FFA657">argv</span><span style="color: #C9D1D9">[</span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">], KEY);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>
<p>该程序的实现过程如下：</p>
<ol>
<li>定义了一个KEY常量作为加密的密钥，自行设定一个字符串即可。</li>
<li>定义了一个BUFFER_SIZE常量表示每次读取文件的缓冲区大小。</li>
<li>编写了一个<code>encrypt</code>函数来加密指定文件夹下的所有文件。该函数参数包括要加密的文件夹路径和密钥。</li>
<li><code>encrypt</code>函数首先打开要加密的文件夹，并创建一个同名的_encrypted文件夹作为加密结果的保存目录。</li>
<li>然后遍历源文件夹下的所有文件，如果是.或..就忽略不处理，否则获取该文件的绝对路径。</li>
<li>打开源文件，并创建一个同名文件（在_encrypted文件夹下）作为目标文件。</li>
<li>读取源文件内容，使用密钥对每个字节进行异或加密，并把加密后的内容写入目标文件中。</li>
<li>关闭源文件和目标文件。</li>
<li><code>main</code>函数检查输入参数是否正确，并调用<code>encrypt</code>函数对输入的目录进行加密。</li>
</ol>
<p>以上程序只是一个简单的加密示例，还有很多地方需要优化。例如加密算法可以更加复杂、安全，可以加入文件鉴别码、异常处理等更多功能，可以根据需求不断扩展。</p>
<h2 id="user-1">user:</h2>
<p>压缩文件加密原理</p>
<h2 id="assistant-1">assistant:</h2>
<p>压缩文件加密一般分为两个步骤：压缩和加密。</p>
<p>压缩是将文件的内容进行压缩，使文件体积更小，以便于传输和存储。压缩算法有很多种，例如LZ77、LZW、Huffman编码等。其中，LZ77和LZW是两种最常用的无损压缩算法。Huffman编码则是一种统计概率并生成最佳编码方式的算法。</p>
<p>加密是指将压缩后的文件内容进行加密，以保证数据的安全性。加密算法也有很多种，例如DES、AES、RSA、Blowfish等。其中，AES和RSA是目前应用最广泛的加密算法。</p>
<p>具体实现上，可以先使用一个压缩算法（如LZ77算法）将要压缩的文件进行处理，得到一个压缩后的结果。然后，在这个压缩后的结果上应用一个加密算法（如AES加密算法），对这个结果进行加密处理。最终得到的就是一个压缩且加密的文件。</p>
<p>在解密的时候，需要首先对加密后的文件进行解密，得到解密后的压缩结果。然后，再使用相应的压缩算法（如LZ77算法）对压缩后的结果进行解压缩，得到最终的文件。需要注意的是，解密过程需要使用相应的密钥来进行解密，否则无法还原原始的文件内容。</p>
<h2 id="user-2">user:</h2>
<p>C语言实现Huffman</p>
<h2 id="assistant-2">assistant:</h2>
<p>Huffman编码是一种用于编码字符的压缩算法，通过根据每个字符出现的频率选择不同的编码方式，可以有效减少存储空间。</p>
<p>下面是一个简单的C语言程序，实现了通过Huffman编码进行字符压缩的功能：</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">#include</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#x3C;stdio.h></span></span>
<span class="line"><span style="color: #FF7B72">#include</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#x3C;stdlib.h></span></span>
<span class="line"><span style="color: #FF7B72">#include</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#x3C;string.h></span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">typedef</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">struct</span><span style="color: #C9D1D9"> _HuffmanTreeNode {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">char</span><span style="color: #C9D1D9"> data;</span><span style="color: #8B949E"> // 字符</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> freq;</span><span style="color: #8B949E"> // 频率</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">struct</span><span style="color: #C9D1D9"> _HuffmanTreeNode </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">left, </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">right;</span></span>
<span class="line"><span style="color: #C9D1D9">} HuffmanTreeNode;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">typedef</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">struct</span><span style="color: #C9D1D9"> _HuffmanTree {</span></span>
<span class="line"><span style="color: #C9D1D9">    HuffmanTreeNode </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">root;</span></span>
<span class="line"><span style="color: #C9D1D9">} HuffmanTree;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">typedef</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">struct</span><span style="color: #C9D1D9"> _HuffmanCode {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">char</span><span style="color: #C9D1D9"> data;</span><span style="color: #8B949E"> // 字符</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">char</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">code;</span><span style="color: #8B949E"> // Huffman编码</span></span>
<span class="line"><span style="color: #C9D1D9">} HuffmanCode;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">void</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">countFreq</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">char</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #FFA657">str</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #FFA657">freq</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> (</span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> i </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">; </span><span style="color: #FFA657">str</span><span style="color: #C9D1D9">[i]; i</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FFA657">freq</span><span style="color: #C9D1D9">[</span><span style="color: #FFA657">str</span><span style="color: #C9D1D9">[i] </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">'a'</span><span style="color: #C9D1D9">]</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">minFreq</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #FFA657">freq</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #FFA657">used</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">n</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> mindex </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">-</span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> (</span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> i </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">; i </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> n; i</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (</span><span style="color: #FF7B72">!</span><span style="color: #FFA657">used</span><span style="color: #C9D1D9">[i] </span><span style="color: #FF7B72">&#x26;&#x26;</span><span style="color: #C9D1D9"> (mindex </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">-</span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">||</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">freq</span><span style="color: #C9D1D9">[i] </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">freq</span><span style="color: #C9D1D9">[mindex])) {</span></span>
<span class="line"><span style="color: #C9D1D9">            mindex </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> i;</span></span>
<span class="line"><span style="color: #C9D1D9">        }</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> mindex;</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">HuffmanTreeNode </span><span style="color: #FF7B72">*</span><span style="color: #D2A8FF">createHuffmanTree</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #FFA657">freq</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #C9D1D9">    HuffmanTreeNode </span><span style="color: #FF7B72">*</span><span style="color: #FFA657">nodes</span><span style="color: #C9D1D9">[</span><span style="color: #79C0FF">26</span><span style="color: #C9D1D9">];</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">used</span><span style="color: #C9D1D9">[</span><span style="color: #79C0FF">26</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> { </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9"> };</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> n </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// 创建叶子节点</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> (</span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> i </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">; i </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">26</span><span style="color: #C9D1D9">; i</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (</span><span style="color: #FFA657">freq</span><span style="color: #C9D1D9">[i] </span><span style="color: #FF7B72">></span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">            HuffmanTreeNode </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">node </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> (HuffmanTreeNode </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">)</span><span style="color: #D2A8FF">malloc</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">sizeof</span><span style="color: #C9D1D9">(HuffmanTreeNode));</span></span>
<span class="line"><span style="color: #C9D1D9">            node->data </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> i </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">'a'</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">            node->freq </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">freq</span><span style="color: #C9D1D9">[i];</span></span>
<span class="line"><span style="color: #C9D1D9">            node->left </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> node->right </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FFA657">nodes</span><span style="color: #C9D1D9">[n</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> node;</span></span>
<span class="line"><span style="color: #C9D1D9">        }</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// 构建Huffman树</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">while</span><span style="color: #C9D1D9"> (n </span><span style="color: #FF7B72">></span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> i </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">minFreq</span><span style="color: #C9D1D9">(freq, used, n);</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> j </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">minFreq</span><span style="color: #C9D1D9">(freq, used, n);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">        HuffmanTreeNode </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">node </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> (HuffmanTreeNode </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">)</span><span style="color: #D2A8FF">malloc</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">sizeof</span><span style="color: #C9D1D9">(HuffmanTreeNode));</span></span>
<span class="line"><span style="color: #C9D1D9">        node->data </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">'</span><span style="color: #79C0FF">\0</span><span style="color: #A5D6FF">'</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">        node->freq </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">freq</span><span style="color: #C9D1D9">[i] </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">freq</span><span style="color: #C9D1D9">[j];</span></span>
<span class="line"><span style="color: #C9D1D9">        node->left </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">nodes</span><span style="color: #C9D1D9">[i];</span></span>
<span class="line"><span style="color: #C9D1D9">        node->right </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">nodes</span><span style="color: #C9D1D9">[j];</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FFA657">used</span><span style="color: #C9D1D9">[i] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">used</span><span style="color: #C9D1D9">[j] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FFA657">nodes</span><span style="color: #C9D1D9">[n</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> node;</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">nodes</span><span style="color: #C9D1D9">[</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">];</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">void</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">destroyHuffmanTree</span><span style="color: #C9D1D9">(HuffmanTreeNode </span><span style="color: #FF7B72">*</span><span style="color: #FFA657">node</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (node </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">destroyHuffmanTree</span><span style="color: #C9D1D9">(node->left);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">destroyHuffmanTree</span><span style="color: #C9D1D9">(node->right);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">free</span><span style="color: #C9D1D9">(node);</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">void</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">generateHuffmanCode</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> HuffmanTreeNode </span><span style="color: #FF7B72">*</span><span style="color: #FFA657">node</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">char</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #FFA657">prefix</span><span style="color: #C9D1D9">, HuffmanCode </span><span style="color: #FF7B72">*</span><span style="color: #FFA657">codes</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (node </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (node->data </span><span style="color: #FF7B72">!=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">'</span><span style="color: #79C0FF">\0</span><span style="color: #A5D6FF">'</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #8B949E">// 叶子节点，保存编码</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> index </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> node->data </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">'a'</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FFA657">codes</span><span style="color: #C9D1D9">[index].data </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> node->data;</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FFA657">codes</span><span style="color: #C9D1D9">[index].code </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">strdup</span><span style="color: #C9D1D9">(prefix);</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">generateHuffmanCode</span><span style="color: #C9D1D9">(node->left, </span><span style="color: #D2A8FF">strcat</span><span style="color: #C9D1D9">(</span><span style="color: #D2A8FF">strcpy</span><span style="color: #C9D1D9">((</span><span style="color: #FF7B72">char</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">)</span><span style="color: #D2A8FF">malloc</span><span style="color: #C9D1D9">(</span><span style="color: #D2A8FF">strlen</span><span style="color: #C9D1D9">(prefix) </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">2</span><span style="color: #C9D1D9">), prefix), </span><span style="color: #A5D6FF">"0"</span><span style="color: #C9D1D9">), codes);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">generateHuffmanCode</span><span style="color: #C9D1D9">(node->right, </span><span style="color: #D2A8FF">strcat</span><span style="color: #C9D1D9">(</span><span style="color: #D2A8FF">strcpy</span><span style="color: #C9D1D9">((</span><span style="color: #FF7B72">char</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">)</span><span style="color: #D2A8FF">malloc</span><span style="color: #C9D1D9">(</span><span style="color: #D2A8FF">strlen</span><span style="color: #C9D1D9">(prefix) </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">2</span><span style="color: #C9D1D9">), prefix), </span><span style="color: #A5D6FF">"1"</span><span style="color: #C9D1D9">), codes);</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">char</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #D2A8FF">compress</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">char</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #FFA657">str</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> HuffmanCode </span><span style="color: #FF7B72">*</span><span style="color: #FFA657">codes</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">size_t</span><span style="color: #C9D1D9"> len </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">strlen</span><span style="color: #C9D1D9">(str);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">char</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">result </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> (</span><span style="color: #FF7B72">char</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">)</span><span style="color: #D2A8FF">malloc</span><span style="color: #C9D1D9">(len </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">10</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FFA657">result</span><span style="color: #C9D1D9">[</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">'</span><span style="color: #79C0FF">\0</span><span style="color: #A5D6FF">'</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> (</span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> i </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">; i </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> len; i</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">char</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">code </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">codes</span><span style="color: #C9D1D9">[</span><span style="color: #FFA657">str</span><span style="color: #C9D1D9">[i] </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">'a'</span><span style="color: #C9D1D9">].code;</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #D2A8FF">strcat</span><span style="color: #C9D1D9">(result, code);</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> result;</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">char</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #D2A8FF">decompress</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">char</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #FFA657">str</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> HuffmanTreeNode </span><span style="color: #FF7B72">*</span><span style="color: #FFA657">root</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">size_t</span><span style="color: #C9D1D9"> len </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">strlen</span><span style="color: #C9D1D9">(str);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">char</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">result </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> (</span><span style="color: #FF7B72">char</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">)</span><span style="color: #D2A8FF">malloc</span><span style="color: #C9D1D9">(len </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FFA657">result</span><span style="color: #C9D1D9">[</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">'</span><span style="color: #79C0FF">\0</span><span style="color: #A5D6FF">'</span><span style="color: #C9D1D9">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> HuffmanTreeNode </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">node </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> root;</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> (</span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> i </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">; i </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> len; i</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (</span><span style="color: #FFA657">str</span><span style="color: #C9D1D9">[i] </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">'0'</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">            node </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> node->left;</span></span>
<span class="line"><span style="color: #C9D1D9">        } </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">            node </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> node->right;</span></span>
<span class="line"><span style="color: #C9D1D9">        }</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (node->data </span><span style="color: #FF7B72">!=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">'</span><span style="color: #79C0FF">\0</span><span style="color: #A5D6FF">'</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #D2A8FF">strncat</span><span style="color: #C9D1D9">(result, </span><span style="color: #FF7B72">&#x26;</span><span style="color: #C9D1D9">node->data, </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">);</span></span>
<span class="line"><span style="color: #C9D1D9">            node </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> root;</span></span>
<span class="line"><span style="color: #C9D1D9">        }</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> result;</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">void</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">printHuffmanCode</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> HuffmanCode </span><span style="color: #FF7B72">*</span><span style="color: #FFA657">codes</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> (</span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> i </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">; i </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">26</span><span style="color: #C9D1D9">; i</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (</span><span style="color: #FFA657">codes</span><span style="color: #C9D1D9">[i].code </span><span style="color: #FF7B72">!=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #D2A8FF">printf</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">"</span><span style="color: #79C0FF">%c</span><span style="color: #A5D6FF">: </span><span style="color: #79C0FF">%s\n</span><span style="color: #A5D6FF">"</span><span style="color: #C9D1D9">, </span><span style="color: #FFA657">codes</span><span style="color: #C9D1D9">[i].data, </span><span style="color: #FFA657">codes</span><span style="color: #C9D1D9">[i].code);</span></span>
<span class="line"><span style="color: #C9D1D9">        }</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">main</span><span style="color: #C9D1D9">()</span></span>
<span class="line"><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">const</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">char</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">str </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">"abbcdaabbcddd"</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">freq</span><span style="color: #C9D1D9">[</span><span style="color: #79C0FF">26</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> { </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9"> };</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">countFreq</span><span style="color: #C9D1D9">(str, freq);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    HuffmanTreeNode </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">root </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">createHuffmanTree</span><span style="color: #C9D1D9">(freq);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    HuffmanCode </span><span style="color: #FFA657">codes</span><span style="color: #C9D1D9">[</span><span style="color: #79C0FF">26</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> { </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9"> };</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">generateHuffmanCode</span><span style="color: #C9D1D9">(root, </span><span style="color: #A5D6FF">""</span><span style="color: #C9D1D9">, codes);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">printf</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">"Huffman Codes:</span><span style="color: #79C0FF">\n</span><span style="color: #A5D6FF">"</span><span style="color: #C9D1D9">);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">printHuffmanCode</span><span style="color: #C9D1D9">(codes);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">char</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">compressed </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">compress</span><span style="color: #C9D1D9">(str, codes);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">printf</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">"Compressed: </span><span style="color: #79C0FF">%s\n</span><span style="color: #A5D6FF">"</span><span style="color: #C9D1D9">, compressed);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">char</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">decompressed </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">decompress</span><span style="color: #C9D1D9">(compressed, root);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">printf</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">"Decompressed: </span><span style="color: #79C0FF">%s\n</span><span style="color: #A5D6FF">"</span><span style="color: #C9D1D9">, decompressed);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// 释放占用的空间</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> (</span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> i </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">; i </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">26</span><span style="color: #C9D1D9">; i</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (</span><span style="color: #FFA657">codes</span><span style="color: #C9D1D9">[i].code </span><span style="color: #FF7B72">!=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #D2A8FF">free</span><span style="color: #C9D1D9">(</span><span style="color: #FFA657">codes</span><span style="color: #C9D1D9">[i].code);</span></span>
<span class="line"><span style="color: #C9D1D9">        }</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">free</span><span style="color: #C9D1D9">(compressed);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">free</span><span style="color: #C9D1D9">(decompressed);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">destroyHuffmanTree</span><span style="color: #C9D1D9">(root);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>
<p>程序的实现步骤如下：</p>
<ol>
<li>定义Huffman树节点和树的数据结构，并定义Huffman编码的数据结构，用于存储字符和对应的编码。</li>
<li>编写函数<code>countFreq</code>来统计字符串中每个字符的出现频率。</li>
<li>编写函数<code>minFreq</code>来查找未使用的频率最小的字符，以便构建Huffman树。</li>
<li>编写函数<code>createHuffmanTree</code>来创建Huffman树。该函数首先创建所有字符的叶子节点，然后逐步构建Huffman树。</li>
<li>编写函数<code>destroyHuffmanTree</code>来销毁Huffman树，释放内存。</li>
<li>编写函数<code>generateHuffmanCode</code>来生成Huffman编码。</li>
<li>编写函数<code>compress</code>来压缩字符串。该函数利用已生成的Huffman编码将字符串压缩成一个二进制串。</li>
<li>编写函数<code>decompress</code>来解压缩字符串。该函数利用Huffman树和压缩后的二进制串还原原始的字符串。</li>
<li>编写函数<code>printHuffmanCode</code>来输出Huffman编码，用于调试和观察。</li>
<li>在<code>main</code>函数中调用上述函数，测试Huffman编码的压缩和解压缩功能。</li>
</ol>
<p>需要注意的是，以上实现只是一个简单的Huffman编码实现，还有很多优化和完善的地方，例如合并Huffman编码比较少的节点、加入文件读写操作、异常处理等等。</p>
<h2 id="user-3">user:</h2>
<p>C语言实现B+树</p>
<h2 id="assistant-3">assistant:</h2>
<p>B+树是一种平衡树结构，适用于磁盘数据访问的场景。下面是一个C语言程序，实现了B+树的基本操作：</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">#include</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#x3C;stdio.h></span></span>
<span class="line"><span style="color: #FF7B72">#include</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#x3C;stdlib.h></span></span>
<span class="line"><span style="color: #FF7B72">#include</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#x3C;stdbool.h></span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">#define</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">MAX_CHILDREN</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">100</span><span style="color: #8B949E"> // 子节点最大个数</span></span>
<span class="line"><span style="color: #FF7B72">#define</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">MIN_CHILDREN</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">50</span><span style="color: #8B949E"> // 子节点最小个数</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">#define</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">MAX_DATA</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">50</span><span style="color: #8B949E"> // 数据最大个数</span></span>
<span class="line"><span style="color: #FF7B72">#define</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">MIN_DATA</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">25</span><span style="color: #8B949E"> // 数据最小个数</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">typedef</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">struct</span><span style="color: #C9D1D9"> _Node {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">key</span><span style="color: #C9D1D9">[MAX_DATA </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">];</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">struct</span><span style="color: #C9D1D9"> _Node </span><span style="color: #FF7B72">*</span><span style="color: #FFA657">child</span><span style="color: #C9D1D9">[MAX_CHILDREN </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">];</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">struct</span><span style="color: #C9D1D9"> _Node </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">next;</span><span style="color: #8B949E"> // 下一个叶子结点</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> numKeys;</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">bool</span><span style="color: #C9D1D9"> isLeaf;</span><span style="color: #8B949E"> // 是否为叶子结点</span></span>
<span class="line"><span style="color: #C9D1D9">} Node;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">Node </span><span style="color: #FF7B72">*</span><span style="color: #D2A8FF">newNode</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">bool</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">leaf</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #C9D1D9">    Node </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">node </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> (Node </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">)</span><span style="color: #D2A8FF">malloc</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">sizeof</span><span style="color: #C9D1D9">(Node));</span></span>
<span class="line"><span style="color: #C9D1D9">    node->numKeys </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">    node->isLeaf </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> leaf;</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> (</span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> i </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">; i </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> MAX_CHILDREN </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">; i</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">        node->child[i] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> node;</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">Node </span><span style="color: #FF7B72">*</span><span style="color: #D2A8FF">search</span><span style="color: #C9D1D9">(Node </span><span style="color: #FF7B72">*</span><span style="color: #FFA657">node</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">key</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> i </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">while</span><span style="color: #C9D1D9"> (i </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> node->numKeys </span><span style="color: #FF7B72">&#x26;&#x26;</span><span style="color: #C9D1D9"> key </span><span style="color: #FF7B72">></span><span style="color: #C9D1D9"> node->key[i]) {</span></span>
<span class="line"><span style="color: #C9D1D9">        i</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (node->isLeaf) {</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (i </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> node->numKeys </span><span style="color: #FF7B72">&#x26;&#x26;</span><span style="color: #C9D1D9"> key </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> node->key[i]) {</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> node;</span></span>
<span class="line"><span style="color: #C9D1D9">        }</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">search</span><span style="color: #C9D1D9">(node->child[i], key);</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">void</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">insertNonFull</span><span style="color: #C9D1D9">(Node </span><span style="color: #FF7B72">*</span><span style="color: #FFA657">node</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">key</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> i </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> node->numKeys;</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (node->isLeaf) {</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">while</span><span style="color: #C9D1D9"> (i </span><span style="color: #FF7B72">></span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">&#x26;&#x26;</span><span style="color: #C9D1D9"> key </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> node->key[i</span><span style="color: #FF7B72">-</span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">]) {</span></span>
<span class="line"><span style="color: #C9D1D9">            node->key[i] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> node->key[i</span><span style="color: #FF7B72">-</span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">];</span></span>
<span class="line"><span style="color: #C9D1D9">            i</span><span style="color: #FF7B72">--</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">        }</span></span>
<span class="line"><span style="color: #C9D1D9">        node->key[i] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> key;</span></span>
<span class="line"><span style="color: #C9D1D9">        node->numKeys</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">    } </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">while</span><span style="color: #C9D1D9"> (i </span><span style="color: #FF7B72">></span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">&#x26;&#x26;</span><span style="color: #C9D1D9"> key </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> node->key[i</span><span style="color: #FF7B72">-</span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">]) {</span></span>
<span class="line"><span style="color: #C9D1D9">            i</span><span style="color: #FF7B72">--</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">        }</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (node->child[i]->numKeys </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> MAX_DATA) {</span><span style="color: #8B949E"> // 分裂子结点</span></span>
<span class="line"><span style="color: #C9D1D9">            Node </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">child </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> node->child[i];</span></span>
<span class="line"><span style="color: #C9D1D9">            Node </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">newChild </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">newNode</span><span style="color: #C9D1D9">(child->isLeaf);</span></span>
<span class="line"><span style="color: #C9D1D9">            newChild->next </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> child->next;</span></span>
<span class="line"><span style="color: #C9D1D9">            child->next </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> newChild;</span><span style="color: #8B949E"> // 维护叶子结点链表</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> (</span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> j </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">; j </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> MIN_DATA; j</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">                newChild->key[j] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> child->key[j</span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9">MIN_DATA];</span></span>
<span class="line"><span style="color: #C9D1D9">            }</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> (</span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> j </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> MIN_DATA; j </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> MAX_DATA; j</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">                child->key[j] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">            }</span></span>
<span class="line"><span style="color: #C9D1D9">            newChild->numKeys </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> MAX_DATA </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> MIN_DATA;</span></span>
<span class="line"><span style="color: #C9D1D9">            child->numKeys </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> MIN_DATA;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> (</span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> j </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> node->numKeys; j </span><span style="color: #FF7B72">></span><span style="color: #C9D1D9"> i; j</span><span style="color: #FF7B72">--</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">                node->child[j</span><span style="color: #FF7B72">+</span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> node->child[j];</span></span>
<span class="line"><span style="color: #C9D1D9">            }</span></span>
<span class="line"><span style="color: #C9D1D9">            node->child[i</span><span style="color: #FF7B72">+</span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> newChild;</span></span>
<span class="line"><span style="color: #C9D1D9">            node->key[i] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> newChild->key[</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">];</span></span>
<span class="line"><span style="color: #C9D1D9">            node->numKeys</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (key </span><span style="color: #FF7B72">></span><span style="color: #C9D1D9"> node->key[i]) {</span></span>
<span class="line"><span style="color: #C9D1D9">                i</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">            }</span></span>
<span class="line"><span style="color: #C9D1D9">        }</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #D2A8FF">insertNonFull</span><span style="color: #C9D1D9">(node->child[i], key);</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">void</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">insert</span><span style="color: #C9D1D9">(Node </span><span style="color: #FF7B72">**</span><span style="color: #FFA657">root</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">key</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (</span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">root </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">root </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">newNode</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">true</span><span style="color: #C9D1D9">);</span></span>
<span class="line"><span style="color: #C9D1D9">        (</span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">root)->key[</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> key;</span></span>
<span class="line"><span style="color: #C9D1D9">        (</span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">root)->numKeys</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">    } </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> ((</span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">root)->numKeys </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> MAX_DATA) {</span><span style="color: #8B949E"> // 分裂根结点</span></span>
<span class="line"><span style="color: #C9D1D9">            Node </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">oldRoot </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">root;</span></span>
<span class="line"><span style="color: #C9D1D9">            Node </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">newRoot </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">newNode</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">false</span><span style="color: #C9D1D9">);</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">root </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> newRoot;</span></span>
<span class="line"><span style="color: #C9D1D9">            newRoot->child[</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> oldRoot;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">            Node </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">newChild </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">newNode</span><span style="color: #C9D1D9">(oldRoot->isLeaf);</span></span>
<span class="line"><span style="color: #C9D1D9">            newChild->next </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> oldRoot->next;</span></span>
<span class="line"><span style="color: #C9D1D9">            oldRoot->next </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> newChild;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">            newRoot->child[</span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> newChild;</span></span>
<span class="line"><span style="color: #C9D1D9">            newRoot->key[</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> newChild->key[</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">];</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">            newChild->numKeys </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> MAX_DATA </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> MIN_DATA;</span></span>
<span class="line"><span style="color: #C9D1D9">            oldRoot->numKeys </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> MIN_DATA;</span></span>
<span class="line"><span style="color: #C9D1D9">            newRoot->numKeys </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> (</span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> i </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">; i </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> MIN_DATA; i</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">                newChild->key[i</span><span style="color: #FF7B72">-</span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> oldRoot->key[i</span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9">MIN_DATA</span><span style="color: #FF7B72">-</span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">];</span></span>
<span class="line"><span style="color: #C9D1D9">                oldRoot->key[i</span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9">MIN_DATA</span><span style="color: #FF7B72">-</span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">            }</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #D2A8FF">insertNonFull</span><span style="color: #C9D1D9">(newRoot, key);</span></span>
<span class="line"><span style="color: #C9D1D9">        } </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #D2A8FF">insertNonFull</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">root, key);</span></span>
<span class="line"><span style="color: #C9D1D9">        }</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">void</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">printTree</span><span style="color: #C9D1D9">(Node </span><span style="color: #FF7B72">*</span><span style="color: #FFA657">node</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> (</span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> i </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">; i </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> node->numKeys; i</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (</span><span style="color: #FF7B72">!</span><span style="color: #C9D1D9">node->isLeaf) {</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #D2A8FF">printTree</span><span style="color: #C9D1D9">(node->child[i]);</span></span>
<span class="line"><span style="color: #C9D1D9">        }</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #D2A8FF">printf</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">"</span><span style="color: #79C0FF">%d</span><span style="color: #A5D6FF"> "</span><span style="color: #C9D1D9">, node->key[i]);</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (</span><span style="color: #FF7B72">!</span><span style="color: #C9D1D9">node->isLeaf) {</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #D2A8FF">printTree</span><span style="color: #C9D1D9">(node->child[node->numKeys]);</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">main</span><span style="color: #C9D1D9">()</span></span>
<span class="line"><span style="color: #C9D1D9">{</span></span>
<span class="line"><span style="color: #C9D1D9">    Node </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">root </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">insert</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">&#x26;</span><span style="color: #C9D1D9">root, </span><span style="color: #79C0FF">10</span><span style="color: #C9D1D9">);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">insert</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">&#x26;</span><span style="color: #C9D1D9">root, </span><span style="color: #79C0FF">20</span><span style="color: #C9D1D9">);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">insert</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">&#x26;</span><span style="color: #C9D1D9">root, </span><span style="color: #79C0FF">5</span><span style="color: #C9D1D9">);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">insert</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">&#x26;</span><span style="color: #C9D1D9">root, </span><span style="color: #79C0FF">6</span><span style="color: #C9D1D9">);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">insert</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">&#x26;</span><span style="color: #C9D1D9">root, </span><span style="color: #79C0FF">12</span><span style="color: #C9D1D9">);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">insert</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">&#x26;</span><span style="color: #C9D1D9">root, </span><span style="color: #79C0FF">30</span><span style="color: #C9D1D9">);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">insert</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">&#x26;</span><span style="color: #C9D1D9">root, </span><span style="color: #79C0FF">7</span><span style="color: #C9D1D9">);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">insert</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">&#x26;</span><span style="color: #C9D1D9">root, </span><span style="color: #79C0FF">17</span><span style="color: #C9D1D9">);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">insert</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">&#x26;</span><span style="color: #C9D1D9">root, </span><span style="color: #79C0FF">19</span><span style="color: #C9D1D9">);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">insert</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">&#x26;</span><span style="color: #C9D1D9">root, </span><span style="color: #79C0FF">25</span><span style="color: #C9D1D9">);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">printTree</span><span style="color: #C9D1D9">(root);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">printf</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">"</span><span style="color: #79C0FF">\n</span><span style="color: #A5D6FF">"</span><span style="color: #C9D1D9">);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    Node </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">node </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">search</span><span style="color: #C9D1D9">(root, </span><span style="color: #79C0FF">7</span><span style="color: #C9D1D9">);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (node </span><span style="color: #FF7B72">!=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #D2A8FF">printf</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">"Found key </span><span style="color: #79C0FF">%d\n</span><span style="color: #A5D6FF">"</span><span style="color: #C9D1D9">, node->key[</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">]);</span></span>
<span class="line"><span style="color: #C9D1D9">    } </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #D2A8FF">printf</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">"Key not found</span><span style="color: #79C0FF">\n</span><span style="color: #A5D6FF">"</span><span style="color: #C9D1D9">);</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    node </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">search</span><span style="color: #C9D1D9">(root, </span><span style="color: #79C0FF">22</span><span style="color: #C9D1D9">);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (node </span><span style="color: #FF7B72">!=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #D2A8FF">printf</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">"Found key </span><span style="color: #79C0FF">%d\n</span><span style="color: #A5D6FF">"</span><span style="color: #C9D1D9">, node->key[</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">]);</span></span>
<span class="line"><span style="color: #C9D1D9">    } </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #D2A8FF">printf</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">"Key not found</span><span style="color: #79C0FF">\n</span><span style="color: #A5D6FF">"</span><span style="color: #C9D1D9">);</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>
<p>程序的实现步骤如下：</p>
<ol>
<li>定义B+树结构体和数据结构，其中保存了每个结点的键和子节点。</li>
<li>定义插入函数<code>insert</code>和插入非满子节点函数<code>insertNonFull</code>。在插入时，需要先判断根结点是否满，如果满了则需要分裂为两个子结点。如果子结点也满了，则需要继续分裂，直到插入成功。</li>
<li>定义查询函数<code>search</code>。在查询中，需要遍历树查找目标键。由于B+树具有天然的有序性，可以利用键的大小关系快速判断下一个子树的方向。</li>
<li>定义打印函数<code>printTree</code>。为了方便调试，可以使用该函数来输出整棵B+树。</li>
<li>在<code>main</code>函数中调用上述函数，测试B+树的基本操作。</li>
</ol>
<p>需要注意的是，由于B+树的结构比较复杂，因此其实现也比较困难。以上实现仅仅是一个简单的B+树实现，还有很多优化和完善的地方，例如改进分裂算法、修改叶子节点链表等等。</p>
<h2 id="user-4">user:</h2>
<p>红黑树</p>
<h2 id="assistant-4">assistant:</h2>
<p>红黑树（Red-Black Tree）是一种自平衡的二叉查找树，它保证了插入、删除、查找等操作的时间复杂度都是 O(log n)，其中 n 是树中元素的个数。</p>
<p>红黑树是满足以下性质的二叉查找树：</p>
<ol>
<li>每个结点要么是红色，要么是黑色。</li>
<li>根结点是黑色。</li>
<li>每个叶子结点（NIL 结点/空结点）都是黑色的（黑色叶子结点不含数据）。</li>
<li>如果一个结点是红色的，则它的两个子结点都是黑色的。</li>
<li>对于每个结点，从该结点到其所有后代叶子结点的简单路径上，均包含相同数目的黑色结点。</li>
</ol>
<p>由于满足以上性质，红黑树在插入和删除结点时，会自动进行旋转、着色等操作，通过保证树的平衡性，从而保证了时间复杂度为 O(log n)。</p>
<p>红黑树的结构相对于普通的二叉查找树会稍复杂，但是通过研究代码和动图演示也可以理解其原理。</p>
<h2 id="user-5">user:</h2>
<p>C语言实现红黑树</p>
<h2 id="assistant-5">assistant:</h2>
<p>下面是一个简单的 C 语言实现红黑树的例子，实现了插入、删除、查找、以及遍历操作：</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">#include</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#x3C;stdio.h></span></span>
<span class="line"><span style="color: #FF7B72">#include</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#x3C;stdlib.h></span></span>
<span class="line"></span>
<span class="line"><span style="color: #8B949E">// 定义红黑树节点的颜色</span></span>
<span class="line"><span style="color: #FF7B72">#define</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">RED</span><span style="color: #C9D1D9">   </span><span style="color: #79C0FF">0</span></span>
<span class="line"><span style="color: #FF7B72">#define</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">BLACK</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span></span>
<span class="line"></span>
<span class="line"><span style="color: #8B949E">// 红黑树节点结构体定义</span></span>
<span class="line"><span style="color: #FF7B72">typedef</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">struct</span><span style="color: #C9D1D9"> Node {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> val;</span><span style="color: #8B949E">               // 节点值</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> color;</span><span style="color: #8B949E">             // 节点颜色：0 表示红色，1 表示黑色</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">struct</span><span style="color: #C9D1D9"> Node </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">left;</span><span style="color: #8B949E">     // 左子树指针</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">struct</span><span style="color: #C9D1D9"> Node </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">right;</span><span style="color: #8B949E">    // 右子树指针</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">struct</span><span style="color: #C9D1D9"> Node </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">parent;</span><span style="color: #8B949E">   // 父节点指针</span></span>
<span class="line"><span style="color: #C9D1D9">} Node;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #8B949E">// 新建节点函数</span></span>
<span class="line"><span style="color: #C9D1D9">Node</span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">createNode</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">val</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">    Node</span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9"> node </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> (Node</span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">) </span><span style="color: #D2A8FF">malloc</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">sizeof</span><span style="color: #C9D1D9">(Node));</span><span style="color: #8B949E">  // 申请节点空间</span></span>
<span class="line"><span style="color: #C9D1D9">    node->val </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> val;</span><span style="color: #8B949E">                            // 节点赋值</span></span>
<span class="line"><span style="color: #C9D1D9">    node->color </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> RED;</span><span style="color: #8B949E">                          // 新节点为红色</span></span>
<span class="line"><span style="color: #C9D1D9">    node->left </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9">;</span><span style="color: #8B949E">                          // 左子树为空</span></span>
<span class="line"><span style="color: #C9D1D9">    node->right </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9">;</span><span style="color: #8B949E">                         // 右子树为空</span></span>
<span class="line"><span style="color: #C9D1D9">    node->parent </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9">;</span><span style="color: #8B949E">                        // 父节点为空</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> node;</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #8B949E">// 左旋函数</span></span>
<span class="line"><span style="color: #FF7B72">void</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">leftRotate</span><span style="color: #C9D1D9">(Node </span><span style="color: #FF7B72">**</span><span style="color: #FFA657">root</span><span style="color: #C9D1D9">, Node </span><span style="color: #FF7B72">*</span><span style="color: #FFA657">node</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">    Node </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">right </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> node->right;</span><span style="color: #8B949E">         // 取出节点的右子树</span></span>
<span class="line"><span style="color: #C9D1D9">    node->right </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> right->left;</span><span style="color: #8B949E">        // 右子树的左子树挂到节点的右子树</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (right->left </span><span style="color: #FF7B72">!=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9">) {</span><span style="color: #8B949E">        // 如果右子树的左子树非空，则修改左子树的父节点指针</span></span>
<span class="line"><span style="color: #C9D1D9">        right->left->parent </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> node;</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">    right->parent </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> node->parent;</span><span style="color: #8B949E">     // 修改右子树的父节点指针</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (node->parent </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9">) {</span><span style="color: #8B949E">       // 如果节点没有父节点，则让右子树成为新的根节点</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">root </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> right;</span></span>
<span class="line"><span style="color: #C9D1D9">    } </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (node </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> node->parent->left) {</span><span style="color: #8B949E">  // 如果节点是其父节点的左节点，则把右子树作为其父节点的左子树</span></span>
<span class="line"><span style="color: #C9D1D9">        node->parent->left </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> right;</span></span>
<span class="line"><span style="color: #C9D1D9">    } </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> {</span><span style="color: #8B949E">                           // 如果节点是其父节点的右节点，则把右子树作为其父节点的右子树</span></span>
<span class="line"><span style="color: #C9D1D9">        node->parent->right </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> right;</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">    right->left </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> node;</span><span style="color: #8B949E">                // 节点成为右子树的左子树</span></span>
<span class="line"><span style="color: #C9D1D9">    node->parent </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> right;</span><span style="color: #8B949E">              // 修改节点的父节点指针为右子树</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #8B949E">// 右旋函数</span></span>
<span class="line"><span style="color: #FF7B72">void</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">rightRotate</span><span style="color: #C9D1D9">(Node </span><span style="color: #FF7B72">**</span><span style="color: #FFA657">root</span><span style="color: #C9D1D9">, Node </span><span style="color: #FF7B72">*</span><span style="color: #FFA657">node</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">    Node </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">left </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> node->left;</span><span style="color: #8B949E">          // 取出节点的左子树</span></span>
<span class="line"><span style="color: #C9D1D9">    node->left </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> left->right;</span><span style="color: #8B949E">         // 左子树的右子树挂到节点的左子树</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (left->right </span><span style="color: #FF7B72">!=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9">) {</span><span style="color: #8B949E">        // 如果左子树的右子树非空，则修改右子树的父节点指针</span></span>
<span class="line"><span style="color: #C9D1D9">        left->right->parent </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> node;</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">    left->parent </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> node->parent;</span><span style="color: #8B949E">      // 修改左子树的父节点指针</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (node->parent </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9">) {</span><span style="color: #8B949E">       // 如果节点没有父节点，则让左子树成为新的根节点</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">root </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> left;</span></span>
<span class="line"><span style="color: #C9D1D9">    } </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (node </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> node->parent->right) {</span><span style="color: #8B949E"> // 如果节点是其父节点的右节点，则把左子树作为其父节点的右子树</span></span>
<span class="line"><span style="color: #C9D1D9">        node->parent->right </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> left;</span></span>
<span class="line"><span style="color: #C9D1D9">    } </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> {</span><span style="color: #8B949E">                           // 如果节点是其父节点的左节点，则把左子树作为其父节点的左子树</span></span>
<span class="line"><span style="color: #C9D1D9">        node->parent->left </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> left;</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">    left->right </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> node;</span><span style="color: #8B949E">               // 节点成为左子树的右子树</span></span>
<span class="line"><span style="color: #C9D1D9">    node->parent </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> left;</span><span style="color: #8B949E">              // 修改节点的父节点指针为左子树</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #8B949E">// 节点插入函数</span></span>
<span class="line"><span style="color: #FF7B72">void</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">rbInsert</span><span style="color: #C9D1D9">(Node </span><span style="color: #FF7B72">**</span><span style="color: #FFA657">root</span><span style="color: #C9D1D9">, Node </span><span style="color: #FF7B72">*</span><span style="color: #FFA657">node</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">    Node </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">y </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">    Node </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">x </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">root;</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">while</span><span style="color: #C9D1D9"> (x </span><span style="color: #FF7B72">!=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9">) {</span><span style="color: #8B949E">               // 找到节点要插入的位置</span></span>
<span class="line"><span style="color: #C9D1D9">        y </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> x;</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (node->val </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> x->val) {</span></span>
<span class="line"><span style="color: #C9D1D9">            x </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> x->left;</span></span>
<span class="line"><span style="color: #C9D1D9">        } </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">            x </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> x->right;</span></span>
<span class="line"><span style="color: #C9D1D9">        }</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">    node->parent </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> y;</span><span style="color: #8B949E">                 // 修改节点的父节点指针</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (y </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9">) {</span><span style="color: #8B949E">                  // 如果树为空，则让新节点成为根节点</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">root </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> node;</span></span>
<span class="line"><span style="color: #C9D1D9">    } </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (node->val </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> y->val) {</span><span style="color: #8B949E">  // 如果节点值小于父节点的值，则让新节点成为父节点的左子树</span></span>
<span class="line"><span style="color: #C9D1D9">        y->left </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> node;</span></span>
<span class="line"><span style="color: #C9D1D9">    } </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> {</span><span style="color: #8B949E">                          // 如果节点值大于等于父节点的值，则让新节点成为父节点的右子树</span></span>
<span class="line"><span style="color: #C9D1D9">        y->right </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> node;</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">    node->left </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9">;</span><span style="color: #8B949E">                // 新节点的左子树为空</span></span>
<span class="line"><span style="color: #C9D1D9">    node->right </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9">;</span><span style="color: #8B949E">               // 新节点的右子树为空</span></span>
<span class="line"><span style="color: #C9D1D9">    node->color </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> RED;</span><span style="color: #8B949E">                // 新节点为红色</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">while</span><span style="color: #C9D1D9"> (node </span><span style="color: #FF7B72">!=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">root </span><span style="color: #FF7B72">&#x26;&#x26;</span><span style="color: #C9D1D9"> node->parent->color </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> RED) {</span><span style="color: #8B949E">  // 如果父节点为红色，则要进行颜色调整和旋转</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (node->parent </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> node->parent->parent->left) {</span><span style="color: #8B949E">  // 如果父节点是左节点</span></span>
<span class="line"><span style="color: #C9D1D9">            Node </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">uncle </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> node->parent->parent->right;</span><span style="color: #8B949E">       // 取出叔叔节点</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (uncle </span><span style="color: #FF7B72">!=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">&#x26;&#x26;</span><span style="color: #C9D1D9"> uncle->color </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> RED) {</span><span style="color: #8B949E">      // 如果叔叔节点为红色，则进行颜色调整</span></span>
<span class="line"><span style="color: #C9D1D9">                node->parent->color </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> BLACK;</span></span>
<span class="line"><span style="color: #C9D1D9">                uncle->color </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> BLACK;</span></span>
<span class="line"><span style="color: #C9D1D9">                node->parent->parent->color </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> RED;</span></span>
<span class="line"><span style="color: #C9D1D9">                node </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> node->parent->parent;</span></span>
<span class="line"><span style="color: #C9D1D9">            } </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> {</span><span style="color: #8B949E">                                        // 如果叔叔节点为黑色，则进行旋转</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (node </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> node->parent->right) {</span></span>
<span class="line"><span style="color: #C9D1D9">                    node </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> node->parent;</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #D2A8FF">leftRotate</span><span style="color: #C9D1D9">(root, node);</span></span>
<span class="line"><span style="color: #C9D1D9">                }</span></span>
<span class="line"><span style="color: #C9D1D9">                node->parent->color </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> BLACK;</span></span>
<span class="line"><span style="color: #C9D1D9">                node->parent->parent->color </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> RED;</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #D2A8FF">rightRotate</span><span style="color: #C9D1D9">(root, node->parent->parent);</span></span>
<span class="line"><span style="color: #C9D1D9">            }</span></span>
<span class="line"><span style="color: #C9D1D9">        } </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> {</span><span style="color: #8B949E">                                               // 如果父节点是右节点，与上面类似</span></span>
<span class="line"><span style="color: #C9D1D9">            Node </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">uncle </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> node->parent->parent->left;</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (uncle </span><span style="color: #FF7B72">!=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">&#x26;&#x26;</span><span style="color: #C9D1D9"> uncle->color </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> RED) {</span></span>
<span class="line"><span style="color: #C9D1D9">                node->parent->color </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> BLACK;</span></span>
<span class="line"><span style="color: #C9D1D9">                uncle->color </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> BLACK;</span></span>
<span class="line"><span style="color: #C9D1D9">                node->parent->parent->color </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> RED;</span></span>
<span class="line"><span style="color: #C9D1D9">                node </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> node->parent->parent;</span></span>
<span class="line"><span style="color: #C9D1D9">            } </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (node </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> node->parent->left) {</span></span>
<span class="line"><span style="color: #C9D1D9">                    node </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> node->parent;</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #D2A8FF">rightRotate</span><span style="color: #C9D1D9">(root, node);</span></span>
<span class="line"><span style="color: #C9D1D9">                }</span></span>
<span class="line"><span style="color: #C9D1D9">                node->parent->color </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> BLACK;</span></span>
<span class="line"><span style="color: #C9D1D9">                node->parent->parent->color </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> RED;</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #D2A8FF">leftRotate</span><span style="color: #C9D1D9">(root, node->parent->parent);</span></span>
<span class="line"><span style="color: #C9D1D9">            }</span></span>
<span class="line"><span style="color: #C9D1D9">        }</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">    (</span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">root)->color </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> BLACK;</span><span style="color: #8B949E">              // 根节点必须为黑色</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #8B949E">// 节点删除函数</span></span>
<span class="line"><span style="color: #FF7B72">void</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">rbDelete</span><span style="color: #C9D1D9">(Node </span><span style="color: #FF7B72">**</span><span style="color: #FFA657">root</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">val</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">    Node </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">z </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">root;</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">while</span><span style="color: #C9D1D9"> (z </span><span style="color: #FF7B72">!=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9">) {</span><span style="color: #8B949E">                 // 查找要删除的节点</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (val </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> z->val) {</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">break</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">        } </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (val </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> z->val) {</span></span>
<span class="line"><span style="color: #C9D1D9">            z </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> z->left;</span></span>
<span class="line"><span style="color: #C9D1D9">        } </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">            z </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> z->right;</span></span>
<span class="line"><span style="color: #C9D1D9">        }</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (z </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9">) {</span><span style="color: #8B949E">                    // 如果找不到要删除的节点，则返回</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">    Node </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">x </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">    Node </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">y </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> z;</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> y_original_color </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> y->color;</span><span style="color: #8B949E">    // 保存要删除的节点的颜色</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (z->left </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9">) {</span><span style="color: #8B949E">              // 如果要删除的节点没有左子树，则直接用右子树取代该节点</span></span>
<span class="line"><span style="color: #C9D1D9">        x </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> z->right;</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #D2A8FF">rbTransplant</span><span style="color: #C9D1D9">(root, z, z->right);</span></span>
<span class="line"><span style="color: #C9D1D9">    } </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (z->right </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9">) {</span><span style="color: #8B949E">      // 如果要删除的节点没有右子树，则直接用左子树取代该节点</span></span>
<span class="line"><span style="color: #C9D1D9">        x </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> z->left;</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #D2A8FF">rbTransplant</span><span style="color: #C9D1D9">(root, z, z->left);</span></span>
<span class="line"><span style="color: #C9D1D9">    } </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> {</span><span style="color: #8B949E">                            // 如果要删除的节点左右子树都不为空，则找到该节点的后继节点来取代该节点</span></span>
<span class="line"><span style="color: #C9D1D9">        y </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">treeMinimum</span><span style="color: #C9D1D9">(z->right);</span></span>
<span class="line"><span style="color: #C9D1D9">        y_original_color </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> y->color;</span></span>
<span class="line"><span style="color: #C9D1D9">        x </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> y->right;</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (y->parent </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> z) {</span><span style="color: #8B949E">           // 如果后继节点是要删除节点的右子树的左节点</span></span>
<span class="line"><span style="color: #C9D1D9">            x->parent </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> y;</span></span>
<span class="line"><span style="color: #C9D1D9">        } </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> {</span><span style="color: #8B949E">                        // 如果后继节点不是要删除节点的右子树的左节点，则用后继节点的右子树取代后继节点</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #D2A8FF">rbTransplant</span><span style="color: #C9D1D9">(root, y, y->right);</span></span>
<span class="line"><span style="color: #C9D1D9">            y->right </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> z->right;</span></span>
<span class="line"><span style="color: #C9D1D9">            y->right->parent </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> y;</span></span>
<span class="line"><span style="color: #C9D1D9">        }</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #D2A8FF">rbTransplant</span><span style="color: #C9D1D9">(root, z, y);</span><span style="color: #8B949E">       // 用后继节点取代要删除的节点</span></span>
<span class="line"><span style="color: #C9D1D9">        y->left </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> z->left;</span></span>
<span class="line"><span style="color: #C9D1D9">        y->left->parent </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> y;</span></span>
<span class="line"><span style="color: #C9D1D9">        y->color </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> z->color;</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (y_original_color </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> BLACK) {</span><span style="color: #8B949E">    // 如果要删除的节点颜色为黑色，则要对树进行调整</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">while</span><span style="color: #C9D1D9"> (x </span><span style="color: #FF7B72">!=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">root </span><span style="color: #FF7B72">&#x26;&#x26;</span><span style="color: #C9D1D9"> (x </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">||</span><span style="color: #C9D1D9"> x->color </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> BLACK)) {</span><span style="color: #8B949E">  // 只有在节点为黑色或为 NULL 时才需要调整，否则节点为红色时可以直接删除</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (x </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> x->parent->left) {</span><span style="color: #8B949E">  // 如果节点是父节点的左节点</span></span>
<span class="line"><span style="color: #C9D1D9">                Node </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">w </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> x->parent->right;</span><span style="color: #8B949E">  // 取出兄弟节点</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (w->color </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> RED) {</span><span style="color: #8B949E">       // 如果兄弟节点为红色，则根据兄弟节点颜色不同进行旋转和颜色调整</span></span>
<span class="line"><span style="color: #C9D1D9">                    w->color </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> BLACK;</span></span>
<span class="line"><span style="color: #C9D1D9">                    x->parent->color </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> RED;</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #D2A8FF">leftRotate</span><span style="color: #C9D1D9">(root, x->parent);</span></span>
<span class="line"><span style="color: #C9D1D9">                    w </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> x->parent->right;</span></span>
<span class="line"><span style="color: #C9D1D9">                }</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> ((w->left </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">||</span><span style="color: #C9D1D9"> w->left->color </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> BLACK) </span><span style="color: #FF7B72">&#x26;&#x26;</span><span style="color: #C9D1D9"> (w->right </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">||</span><span style="color: #C9D1D9"> w->right->color </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> BLACK)) {</span><span style="color: #8B949E"> // 如果兄弟节点的左右子节点均为黑色，则把兄弟节点变为红色，并以其父节点为新的节点进行操作</span></span>
<span class="line"><span style="color: #C9D1D9">                    w->color </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> RED;</span></span>
<span class="line"><span style="color: #C9D1D9">                    x </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> x->parent;</span></span>
<span class="line"><span style="color: #C9D1D9">                } </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (w->right </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">||</span><span style="color: #C9D1D9"> w->right->color </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> BLACK) {</span><span style="color: #8B949E">  // 如果兄弟节点的右子节点为黑色，则把兄弟节点的左子节点变为黑色，并对兄弟节点进行旋转和调整颜色</span></span>
<span class="line"><span style="color: #C9D1D9">                        </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (w->left </span><span style="color: #FF7B72">!=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">                            w->left->color </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> BLACK;</span></span>
<span class="line"><span style="color: #C9D1D9">                        }</span></span>
<span class="line"><span style="color: #C9D1D9">                        w->color </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> RED;</span></span>
<span class="line"><span style="color: #C9D1D9">                        </span><span style="color: #D2A8FF">rightRotate</span><span style="color: #C9D1D9">(root, w);</span></span>
<span class="line"><span style="color: #C9D1D9">                        w </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> x->parent->right;</span></span>
<span class="line"><span style="color: #C9D1D9">                    }</span></span>
<span class="line"><span style="color: #C9D1D9">                    w->color </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> x->parent->color;</span><span style="color: #8B949E">                       // 将兄弟节点颜色设置为其父节点的颜色，并把其父节点和兄弟节点右子节点的颜色设为黑色</span></span>
<span class="line"><span style="color: #C9D1D9">                    x->parent->color </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> BLACK;</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (w->right </span><span style="color: #FF7B72">!=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">                        w->right->color </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> BLACK;</span></span>
<span class="line"><span style="color: #C9D1D9">                    }</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #D2A8FF">leftRotate</span><span style="color: #C9D1D9">(root, x->parent);</span><span style="color: #8B949E">                        // 对父节点进行左旋</span></span>
<span class="line"><span style="color: #C9D1D9">                    x </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">root;</span><span style="color: #8B949E">                                            // 操作结束</span></span>
<span class="line"><span style="color: #C9D1D9">                }</span></span>
<span class="line"><span style="color: #C9D1D9">            } </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> {</span><span style="color: #8B949E">          // 下面对称的情况</span></span>
<span class="line"><span style="color: #C9D1D9">                Node </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">w </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> x->parent->left;</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (w->color </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> RED) {</span></span>
<span class="line"><span style="color: #C9D1D9">                    w->color </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> BLACK;</span></span>
<span class="line"><span style="color: #C9D1D9">                    x->parent->color </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> RED;</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #D2A8FF">rightRotate</span><span style="color: #C9D1D9">(root, x->parent);</span></span>
<span class="line"><span style="color: #C9D1D9">                    w </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> x->parent->left;</span></span>
<span class="line"><span style="color: #C9D1D9">                }</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> ((w->left </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">||</span><span style="color: #C9D1D9"> w->left->color </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> BLACK) </span><span style="color: #FF7B72">&#x26;&#x26;</span><span style="color: #C9D1D9"> (w->right </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">||</span><span style="color: #C9D1D9"> w->right->color </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> BLACK)) {</span></span>
<span class="line"><span style="color: #C9D1D9">                    w->color </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> RED;</span></span>
<span class="line"><span style="color: #C9D1D9">                    x </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> x->parent;</span></span>
<span class="line"><span style="color: #C9D1D9">                } </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (w->left </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">||</span><span style="color: #C9D1D9"> w->left->color </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> BLACK) {</span></span>
<span class="line"><span style="color: #C9D1D9">                        </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (w->right </span><span style="color: #FF7B72">!=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">                            w->right->color </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> BLACK;</span></span>
<span class="line"><span style="color: #C9D1D9">                        }</span></span>
<span class="line"><span style="color: #C9D1D9">                        w->color </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> RED;</span></span>
<span class="line"><span style="color: #C9D1D9">                        </span><span style="color: #D2A8FF">leftRotate</span><span style="color: #C9D1D9">(root, w);</span></span>
<span class="line"><span style="color: #C9D1D9">                        w </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> x->parent->left;</span></span>
<span class="line"><span style="color: #C9D1D9">                    }</span></span>
<span class="line"><span style="color: #C9D1D9">                    w->color </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> x->parent->color;</span></span>
<span class="line"><span style="color: #C9D1D9">                    x->parent->color </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> BLACK;</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (w->left </span><span style="color: #FF7B72">!=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">                        w->left->color </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> BLACK;</span></span>
<span class="line"><span style="color: #C9D1D9">                    }</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #D2A8FF">rightRotate</span><span style="color: #C9D1D9">(root, x->parent);</span></span>
<span class="line"><span style="color: #C9D1D9">                    x </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">root;</span></span>
<span class="line"><span style="color: #C9D1D9">                }</span></span>
<span class="line"><span style="color: #C9D1D9">            }</span></span>
<span class="line"><span style="color: #C9D1D9">        }</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (x </span><span style="color: #FF7B72">!=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">            x->color </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> BLACK;</span></span>
<span class="line"><span style="color: #C9D1D9">        }</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #8B949E">// 节点查找函数</span></span>
<span class="line"><span style="color: #C9D1D9">Node</span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">rbSearch</span><span style="color: #C9D1D9">(Node </span><span style="color: #FF7B72">*</span><span style="color: #FFA657">node</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">val</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (node </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">||</span><span style="color: #C9D1D9"> node->val </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> val) {</span><span style="color: #8B949E">  // 如果节点为空或者节点值等于给定值，则返回该节点</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> node;</span></span>
<span class="line"><span style="color: #C9D1D9">    } </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (val </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> node->val) {</span><span style="color: #8B949E">            // 如果给定值小于节点值，则在左子树中查找</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">rbSearch</span><span style="color: #C9D1D9">(node->left, val);</span></span>
<span class="line"><span style="color: #C9D1D9">    } </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> {</span><span style="color: #8B949E">                                  // 如果给定值大于节点值，则在右子树中查找</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">rbSearch</span><span style="color: #C9D1D9">(node->right, val);</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #8B949E">// 中序遍历函数</span></span>
<span class="line"><span style="color: #FF7B72">void</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">inorderTraversal</span><span style="color: #C9D1D9">(Node </span><span style="color: #FF7B72">*</span><span style="color: #FFA657">node</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (node </span><span style="color: #FF7B72">!=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #D2A8FF">inorderTraversal</span><span style="color: #C9D1D9">(node->left);</span><span style="color: #8B949E">     // 遍历左子树</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #D2A8FF">printf</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">"</span><span style="color: #79C0FF">%d%c</span><span style="color: #A5D6FF">"</span><span style="color: #C9D1D9">, node->val, node->color </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> RED </span><span style="color: #FF7B72">?</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">'R'</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">:</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">'B'</span><span style="color: #C9D1D9">);</span><span style="color: #8B949E">  // 输出节点信息</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #D2A8FF">inorderTraversal</span><span style="color: #C9D1D9">(node->right);</span><span style="color: #8B949E">    // 遍历右子树</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #8B949E">// 主函数</span></span>
<span class="line"><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">main</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">    Node </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">root </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// 添加测试数据</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">rbInsert</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">&#x26;</span><span style="color: #C9D1D9">root, </span><span style="color: #D2A8FF">createNode</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">5</span><span style="color: #C9D1D9">));</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">rbInsert</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">&#x26;</span><span style="color: #C9D1D9">root, </span><span style="color: #D2A8FF">createNode</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">3</span><span style="color: #C9D1D9">));</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">rbInsert</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">&#x26;</span><span style="color: #C9D1D9">root, </span><span style="color: #D2A8FF">createNode</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">7</span><span style="color: #C9D1D9">));</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">rbInsert</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">&#x26;</span><span style="color: #C9D1D9">root, </span><span style="color: #D2A8FF">createNode</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">));</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">rbInsert</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">&#x26;</span><span style="color: #C9D1D9">root, </span><span style="color: #D2A8FF">createNode</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">9</span><span style="color: #C9D1D9">));</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">rbInsert</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">&#x26;</span><span style="color: #C9D1D9">root, </span><span style="color: #D2A8FF">createNode</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">2</span><span style="color: #C9D1D9">));</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">rbInsert</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">&#x26;</span><span style="color: #C9D1D9">root, </span><span style="color: #D2A8FF">createNode</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">6</span><span style="color: #C9D1D9">));</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">rbInsert</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">&#x26;</span><span style="color: #C9D1D9">root, </span><span style="color: #D2A8FF">createNode</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">8</span><span style="color: #C9D1D9">));</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">rbInsert</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">&#x26;</span><span style="color: #C9D1D9">root, </span><span style="color: #D2A8FF">createNode</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">4</span><span style="color: #C9D1D9">));</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// 输出添加后的红黑树</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">inorderTraversal</span><span style="color: #C9D1D9">(root);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">printf</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">"</span><span style="color: #79C0FF">\n</span><span style="color: #A5D6FF">"</span><span style="color: #C9D1D9">);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// 删除测试数据</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">rbDelete</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">&#x26;</span><span style="color: #C9D1D9">root, </span><span style="color: #79C0FF">4</span><span style="color: #C9D1D9">);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">rbDelete</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">&#x26;</span><span style="color: #C9D1D9">root, </span><span style="color: #79C0FF">5</span><span style="color: #C9D1D9">);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">rbDelete</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">&#x26;</span><span style="color: #C9D1D9">root, </span><span style="color: #79C0FF">3</span><span style="color: #C9D1D9">);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// 输出删除后的红黑树</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">inorderTraversal</span><span style="color: #C9D1D9">(root);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">printf</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">"</span><span style="color: #79C0FF">\n</span><span style="color: #A5D6FF">"</span><span style="color: #C9D1D9">);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// 查找节点</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> val </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">7</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">    Node </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9">node </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">rbSearch</span><span style="color: #C9D1D9">(root, val);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (node </span><span style="color: #FF7B72">!=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">NULL</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #D2A8FF">printf</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">"Node </span><span style="color: #79C0FF">%d</span><span style="color: #A5D6FF"> found</span><span style="color: #79C0FF">\n</span><span style="color: #A5D6FF">"</span><span style="color: #C9D1D9">, val);</span></span>
<span class="line"><span style="color: #C9D1D9">    } </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #D2A8FF">printf</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">"Node </span><span style="color: #79C0FF">%d</span><span style="color: #A5D6FF"> not found</span><span style="color: #79C0FF">\n</span><span style="color: #A5D6FF">"</span><span style="color: #C9D1D9">, val);</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>
<p>在这个例子中，我们定义了红黑树节点的一些属性和方法，包括新建节点、左旋、右旋、插入节点、删除节点、查找节点、以及中序遍历等。</p>
<p>我们添加一些测试数据，然后输出红黑树，删除一些测试数据，然后再次输出红黑树，最后通过查找函数查找特定节点。</p>
<h2 id="user-6">user:</h2>
<p>堆排序</p>
<h2 id="assistant-6">assistant:</h2>
<p>堆排序是一种基于二叉堆的排序算法。它的基本思想是首先将待排序的数据构建成一个二叉堆，然后将堆顶元素移出堆，并将堆的最后一个元素放到堆顶，接着调整堆以符合堆的性质，重复以上步骤直到堆为空。因为堆排序基于堆的性质，它具有时间复杂度为 $O(nlogn)$，并且不需要额外的空间开销，因此在大多数情况下它比快速排序和归并排序效率更高。</p>
<p>堆排序可以分为两个主要的过程：建堆和排序。</p>
<p>建堆的过程：</p>
<ol>
<li>
<p>将待排序的数据按照完全二叉树的形式存储起来。</p>
</li>
<li>
<p>从最后一个非叶子节点开始调整堆，使得堆的每个节点都满足堆的性质。调整堆的过程可以通过下面的代码实现：</p>
</li>
</ol>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">heapify</span><span style="color: #C9D1D9">(arr, n, i):</span></span>
<span class="line"><span style="color: #C9D1D9">    largest </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> i</span></span>
<span class="line"><span style="color: #C9D1D9">    l </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">2</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9"> i </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span></span>
<span class="line"><span style="color: #C9D1D9">    r </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">2</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9"> i </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">2</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E"># 找出左右子节点中的最大值</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> l </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> n </span><span style="color: #FF7B72">and</span><span style="color: #C9D1D9"> arr[l] </span><span style="color: #FF7B72">></span><span style="color: #C9D1D9"> arr[largest]:</span></span>
<span class="line"><span style="color: #C9D1D9">        largest </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> l</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> r </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> n </span><span style="color: #FF7B72">and</span><span style="color: #C9D1D9"> arr[r] </span><span style="color: #FF7B72">></span><span style="color: #C9D1D9"> arr[largest]:</span></span>
<span class="line"><span style="color: #C9D1D9">        largest </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> r</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E"># 如果最大值不是根节点，则交换根节点和最大节点的值，并再次调整堆</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> largest </span><span style="color: #FF7B72">!=</span><span style="color: #C9D1D9"> i:</span></span>
<span class="line"><span style="color: #C9D1D9">        arr[i], arr[largest] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> arr[largest], arr[i]</span></span>
<span class="line"><span style="color: #C9D1D9">        heapify(arr, n, largest)</span></span></code></pre>
<p>排序过程：</p>
<ol>
<li>
<p>从堆的根节点开始，将堆的最后一个节点和根节点交换，然后将堆的大小减一。</p>
</li>
<li>
<p>对堆进行调整，使得堆的每个节点都满足堆的性质。</p>
</li>
<li>
<p>重复以上步骤，直到堆为空。</p>
</li>
</ol>
<p>下面是堆排序的完整代码：</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">heapify</span><span style="color: #C9D1D9">(arr, n, i):</span></span>
<span class="line"><span style="color: #C9D1D9">    largest </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> i</span></span>
<span class="line"><span style="color: #C9D1D9">    l </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">2</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9"> i </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span></span>
<span class="line"><span style="color: #C9D1D9">    r </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">2</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9"> i </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">2</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E"># 找出左右子节点中的最大值</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> l </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> n </span><span style="color: #FF7B72">and</span><span style="color: #C9D1D9"> arr[l] </span><span style="color: #FF7B72">></span><span style="color: #C9D1D9"> arr[largest]:</span></span>
<span class="line"><span style="color: #C9D1D9">        largest </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> l</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> r </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> n </span><span style="color: #FF7B72">and</span><span style="color: #C9D1D9"> arr[r] </span><span style="color: #FF7B72">></span><span style="color: #C9D1D9"> arr[largest]:</span></span>
<span class="line"><span style="color: #C9D1D9">        largest </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> r</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E"># 如果最大值不是根节点，则交换根节点和最大节点的值，并再次调整堆</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> largest </span><span style="color: #FF7B72">!=</span><span style="color: #C9D1D9"> i:</span></span>
<span class="line"><span style="color: #C9D1D9">        arr[i], arr[largest] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> arr[largest], arr[i]</span></span>
<span class="line"><span style="color: #C9D1D9">        heapify(arr, n, largest)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">def</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">heapSort</span><span style="color: #C9D1D9">(arr):</span></span>
<span class="line"><span style="color: #C9D1D9">    n </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">len</span><span style="color: #C9D1D9">(arr)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E"># 建堆</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> i </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">range</span><span style="color: #C9D1D9">(n </span><span style="color: #FF7B72">//</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">2</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">-</span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">-</span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">):</span></span>
<span class="line"><span style="color: #C9D1D9">        heapify(arr, n, i)</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E"># 排序</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> i </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">range</span><span style="color: #C9D1D9">(n </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">, </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">-</span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">):</span></span>
<span class="line"><span style="color: #C9D1D9">        arr[</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">], arr[i] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> arr[i], arr[</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">]</span></span>
<span class="line"><span style="color: #C9D1D9">        heapify(arr, i, </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">)</span></span></code></pre>
<p>可以使用下面的代码测试堆排序的性能：</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> random</span></span>
<span class="line"><span style="color: #FF7B72">import</span><span style="color: #C9D1D9"> time</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">arr </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> [random.randint(</span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">, </span><span style="color: #79C0FF">100000</span><span style="color: #C9D1D9">) </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> i </span><span style="color: #FF7B72">in</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">range</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">10000</span><span style="color: #C9D1D9">)]</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">start </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> time.time()</span></span>
<span class="line"><span style="color: #C9D1D9">heapSort(arr)</span></span>
<span class="line"><span style="color: #C9D1D9">end </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> time.time()</span></span>
<span class="line"></span>
<span class="line"><span style="color: #79C0FF">print</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">"排序时间为："</span><span style="color: #C9D1D9">, end </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> start)</span></span></code></pre>
<h2 id="user-7">user:</h2>
<p>C语言实现</p>
<h2 id="assistant-7">assistant:</h2>
<p>堆排序的C语言实现如下：</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">#include</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#x3C;stdio.h></span></span>
<span class="line"><span style="color: #FF7B72">#include</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#x3C;stdlib.h></span></span>
<span class="line"><span style="color: #FF7B72">#include</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#x3C;time.h></span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">void</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">heapify</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">arr</span><span style="color: #FF7B72">[]</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">n</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">i</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> largest </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> i;</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> l </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">2</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9"> i </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> r </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">2</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">*</span><span style="color: #C9D1D9"> i </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">2</span><span style="color: #C9D1D9">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// 找出左右子节点中的最大值</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (l </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> n </span><span style="color: #FF7B72">&#x26;&#x26;</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">arr</span><span style="color: #C9D1D9">[l] </span><span style="color: #FF7B72">></span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">arr</span><span style="color: #C9D1D9">[largest])</span></span>
<span class="line"><span style="color: #C9D1D9">        largest </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> l;</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (r </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> n </span><span style="color: #FF7B72">&#x26;&#x26;</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">arr</span><span style="color: #C9D1D9">[r] </span><span style="color: #FF7B72">></span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">arr</span><span style="color: #C9D1D9">[largest])</span></span>
<span class="line"><span style="color: #C9D1D9">        largest </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> r;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// 如果最大值不是根节点，则交换根节点和最大节点的值，并再次调整堆</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (largest </span><span style="color: #FF7B72">!=</span><span style="color: #C9D1D9"> i) {</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> temp </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">arr</span><span style="color: #C9D1D9">[i];</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FFA657">arr</span><span style="color: #C9D1D9">[i] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">arr</span><span style="color: #C9D1D9">[largest];</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FFA657">arr</span><span style="color: #C9D1D9">[largest] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> temp;</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #D2A8FF">heapify</span><span style="color: #C9D1D9">(arr, n, largest);</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">void</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">heapSort</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">arr</span><span style="color: #FF7B72">[]</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">n</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// 建堆</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> (</span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> i </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> n </span><span style="color: #FF7B72">/</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">2</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">; i </span><span style="color: #FF7B72">>=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">; i</span><span style="color: #FF7B72">--</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #D2A8FF">heapify</span><span style="color: #C9D1D9">(arr, n, i);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// 排序</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> (</span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> i </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> n </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">; i </span><span style="color: #FF7B72">>=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">; i</span><span style="color: #FF7B72">--</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> temp </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">arr</span><span style="color: #C9D1D9">[</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">];</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FFA657">arr</span><span style="color: #C9D1D9">[</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">arr</span><span style="color: #C9D1D9">[i];</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FFA657">arr</span><span style="color: #C9D1D9">[i] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> temp;</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #D2A8FF">heapify</span><span style="color: #C9D1D9">(arr, i, </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">);</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">main</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">arr</span><span style="color: #C9D1D9">[</span><span style="color: #79C0FF">10000</span><span style="color: #C9D1D9">];</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">srand</span><span style="color: #C9D1D9">(</span><span style="color: #D2A8FF">time</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">));</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> (</span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> i </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">; i </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">10000</span><span style="color: #C9D1D9">; i</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FFA657">arr</span><span style="color: #C9D1D9">[i] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">rand</span><span style="color: #C9D1D9">() </span><span style="color: #FF7B72">%</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">100000</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> n </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">sizeof</span><span style="color: #C9D1D9">(arr) </span><span style="color: #FF7B72">/</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">sizeof</span><span style="color: #C9D1D9">(</span><span style="color: #FFA657">arr</span><span style="color: #C9D1D9">[</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">]);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">clock_t</span><span style="color: #C9D1D9"> start </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">clock</span><span style="color: #C9D1D9">();</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">heapSort</span><span style="color: #C9D1D9">(arr, n);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">clock_t</span><span style="color: #C9D1D9"> end </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">clock</span><span style="color: #C9D1D9">();</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">printf</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">"排序时间为：</span><span style="color: #79C0FF">%lf</span><span style="color: #A5D6FF">秒</span><span style="color: #79C0FF">\n</span><span style="color: #A5D6FF">"</span><span style="color: #C9D1D9">, (</span><span style="color: #FF7B72">double</span><span style="color: #C9D1D9">)(end </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> start) </span><span style="color: #FF7B72">/</span><span style="color: #C9D1D9"> CLOCKS_PER_SEC);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>
<p>可以使用下面的命令编译并运行程序：</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">gcc heap_sort.c -o heap_sort</span></span>
<span class="line"><span style="color: #C9D1D9">./heap_sort</span></span></code></pre>
<h2 id="user-8">user:</h2>
<p>最小二叉树</p>
<h2 id="assistant-8">assistant:</h2>
<p>最小二叉树（Minimum Spanning Tree，MST）是指在一个连通无向图中找到一棵包含所有顶点且边权值之和最小的生成树。</p>
<p>Kruskal算法和Prim算法是目前求解最小二叉树最为常用的两种算法。</p>
<p>Kruskal算法的基本思想是先将图中所有的边按照权值从小到大排序，然后依次选取每一条边。如果这条边连通的两个顶点已经在同一棵树中，则舍去这条边，否则将其加入最小二叉树中。最终得到的就是原图的最小二叉树。</p>
<p>Prim算法的基本思想是用一个优先队列来维护所有已经加入最小二叉树的节点的邻接边。初始状态下只选择了一个节点，将其邻接边加入队列中，并选择一条权值最小的边加入最小二叉树，然后将与该边相连的节点添加到最小二叉树中。接着再将这些新节点的邻接边加入队列中，重复以上步骤直到所有节点都加入了最小二叉树。</p>
<p>下面是Kruskal算法和Prim算法的C语言实现示例：</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">#include</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#x3C;stdio.h></span></span>
<span class="line"><span style="color: #FF7B72">#include</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#x3C;stdlib.h></span></span>
<span class="line"><span style="color: #FF7B72">#include</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#x3C;string.h></span></span>
<span class="line"></span>
<span class="line"><span style="color: #8B949E">// 最大顶点数和最大边数</span></span>
<span class="line"><span style="color: #FF7B72">#define</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">MAX_VERTICES</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1000</span></span>
<span class="line"><span style="color: #FF7B72">#define</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">MAX_EDGES</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">10000</span></span>
<span class="line"></span>
<span class="line"><span style="color: #8B949E">// 存储边的结构体</span></span>
<span class="line"><span style="color: #FF7B72">struct</span><span style="color: #C9D1D9"> edge {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> src;</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> dest;</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> weight;</span></span>
<span class="line"><span style="color: #C9D1D9">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #8B949E">// 并查集结构体</span></span>
<span class="line"><span style="color: #FF7B72">struct</span><span style="color: #C9D1D9"> disjoint_set {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">parent</span><span style="color: #C9D1D9">[MAX_VERTICES];</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">rank</span><span style="color: #C9D1D9">[MAX_VERTICES];</span></span>
<span class="line"><span style="color: #C9D1D9">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #8B949E">// 创建一个并查集，所有元素的父节点都指向自己</span></span>
<span class="line"><span style="color: #FF7B72">void</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">create_set</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">struct</span><span style="color: #C9D1D9"> disjoint_set </span><span style="color: #FF7B72">*</span><span style="color: #FFA657">set</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">n</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> (</span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> i </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">; i </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> n; i</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">        set->parent[i] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> i;</span></span>
<span class="line"><span style="color: #C9D1D9">        set->rank[i] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #8B949E">// 查找元素所在集合的代表元素</span></span>
<span class="line"><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">find_set</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">struct</span><span style="color: #C9D1D9"> disjoint_set </span><span style="color: #FF7B72">*</span><span style="color: #FFA657">set</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">x</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (set->parent[x] </span><span style="color: #FF7B72">!=</span><span style="color: #C9D1D9"> x)</span></span>
<span class="line"><span style="color: #C9D1D9">        set->parent[x] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">find_set</span><span style="color: #C9D1D9">(set, set->parent[x]);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> set->parent[x];</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #8B949E">// 合并两个集合</span></span>
<span class="line"><span style="color: #FF7B72">void</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">union_set</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">struct</span><span style="color: #C9D1D9"> disjoint_set </span><span style="color: #FF7B72">*</span><span style="color: #FFA657">set</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">x</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">y</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> root_x </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">find_set</span><span style="color: #C9D1D9">(set, x);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> root_y </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">find_set</span><span style="color: #C9D1D9">(set, y);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (root_x </span><span style="color: #FF7B72">!=</span><span style="color: #C9D1D9"> root_y) {</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (set->rank[root_x] </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> set->rank[root_y])</span></span>
<span class="line"><span style="color: #C9D1D9">            set->parent[root_x] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> root_y;</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (set->rank[root_x] </span><span style="color: #FF7B72">></span><span style="color: #C9D1D9"> set->rank[root_y])</span></span>
<span class="line"><span style="color: #C9D1D9">            set->parent[root_y] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> root_x;</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">else</span><span style="color: #C9D1D9"> {</span></span>
<span class="line"><span style="color: #C9D1D9">            set->parent[root_y] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> root_x;</span></span>
<span class="line"><span style="color: #C9D1D9">            set->rank[root_x]</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">        }</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #8B949E">// 根据权值从小到大对边进行排序</span></span>
<span class="line"><span style="color: #FF7B72">void</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">sort_edges</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">struct</span><span style="color: #C9D1D9"> edge </span><span style="color: #FF7B72">*</span><span style="color: #FFA657">edges</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">n</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> (</span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> i </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">; i </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> n </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">; i</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> (</span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> j </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">; j </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> n </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> i </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">; j</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (</span><span style="color: #FFA657">edges</span><span style="color: #C9D1D9">[j].weight </span><span style="color: #FF7B72">></span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">edges</span><span style="color: #C9D1D9">[j </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">].weight) {</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">struct</span><span style="color: #C9D1D9"> edge temp </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">edges</span><span style="color: #C9D1D9">[j];</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">edges</span><span style="color: #C9D1D9">[j] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">edges</span><span style="color: #C9D1D9">[j </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">];</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">edges</span><span style="color: #C9D1D9">[j </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> temp;</span></span>
<span class="line"><span style="color: #C9D1D9">            }</span></span>
<span class="line"><span style="color: #C9D1D9">        }</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #8B949E">// Kruskal算法</span></span>
<span class="line"><span style="color: #FF7B72">void</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">kruskal</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">struct</span><span style="color: #C9D1D9"> edge </span><span style="color: #FF7B72">*</span><span style="color: #FFA657">edges</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">n</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">m</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// 对边进行排序</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">sort_edges</span><span style="color: #C9D1D9">(edges, m);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// 创建一个并查集，设置所有节点的父节点为自己</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">struct</span><span style="color: #C9D1D9"> disjoint_set set;</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">create_set</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">&#x26;</span><span style="color: #C9D1D9">set, n);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// 记录已经选择的边的数量</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> count </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// 遍历所有边，如果两个顶点不在同一棵树中，则选择这条边</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> (</span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> i </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">; i </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> m; i</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> src </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">edges</span><span style="color: #C9D1D9">[i].src;</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> dest </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">edges</span><span style="color: #C9D1D9">[i].dest;</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> weight </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">edges</span><span style="color: #C9D1D9">[i].weight;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (</span><span style="color: #D2A8FF">find_set</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">&#x26;</span><span style="color: #C9D1D9">set, src) </span><span style="color: #FF7B72">!=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">find_set</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">&#x26;</span><span style="color: #C9D1D9">set, dest)) {</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #D2A8FF">union_set</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">&#x26;</span><span style="color: #C9D1D9">set, src, dest);</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #D2A8FF">printf</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">"(</span><span style="color: #79C0FF">%d</span><span style="color: #A5D6FF">, </span><span style="color: #79C0FF">%d</span><span style="color: #A5D6FF">) </span><span style="color: #79C0FF">%d\n</span><span style="color: #A5D6FF">"</span><span style="color: #C9D1D9">, src, dest, weight);</span></span>
<span class="line"><span style="color: #C9D1D9">            count</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #8B949E">// 如果已经选择了n-1条边，则可以退出循环</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (count </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> n </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">break</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #8B949E">// Prim算法</span></span>
<span class="line"><span style="color: #FF7B72">void</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">prim</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> graph</span><span style="color: #FF7B72">[]</span><span style="color: #C9D1D9">[MAX_VERTICES], </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">n</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// 用于记录在生成树中的节点</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">in_mst</span><span style="color: #C9D1D9">[MAX_VERTICES];</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">memset</span><span style="color: #C9D1D9">(in_mst, </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">sizeof</span><span style="color: #C9D1D9">(in_mst));</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// 用于记录每个节点在已经加入生成树的最小边</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">min_edge</span><span style="color: #C9D1D9">[MAX_VERTICES];</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> (</span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> i </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">; i </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> n; i</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FFA657">min_edge</span><span style="color: #C9D1D9">[i] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">100000000</span><span style="color: #C9D1D9">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// 将0号节点加入生成树</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FFA657">in_mst</span><span style="color: #C9D1D9">[</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// 记录新加入生成树的节点和原始节点</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> new_node, old_node;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// 不断向生成树中加入新的节点，直到所有节点都加入</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> (</span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> i </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">; i </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> n </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">; i</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> min_weight </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">100000000</span><span style="color: #C9D1D9">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #8B949E">// 遍历所有已经加入生成树的节点的邻接边</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> (</span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> j </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">; j </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> n; j</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (</span><span style="color: #FFA657">in_mst</span><span style="color: #C9D1D9">[j] </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> (</span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> k </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">; k </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> n; k</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">                    </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (</span><span style="color: #FFA657">graph</span><span style="color: #C9D1D9">[j][k] </span><span style="color: #FF7B72">&#x26;&#x26;</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">in_mst</span><span style="color: #C9D1D9">[k] </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">&#x26;&#x26;</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">min_edge</span><span style="color: #C9D1D9">[k] </span><span style="color: #FF7B72">></span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">graph</span><span style="color: #C9D1D9">[j][k]) {</span></span>
<span class="line"><span style="color: #C9D1D9">                        </span><span style="color: #FFA657">min_edge</span><span style="color: #C9D1D9">[k] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">graph</span><span style="color: #C9D1D9">[j][k];</span></span>
<span class="line"><span style="color: #C9D1D9">                        </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (</span><span style="color: #FFA657">min_edge</span><span style="color: #C9D1D9">[k] </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> min_weight) {</span></span>
<span class="line"><span style="color: #C9D1D9">                            new_node </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> k;</span></span>
<span class="line"><span style="color: #C9D1D9">                            old_node </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> j;</span></span>
<span class="line"><span style="color: #C9D1D9">                            min_weight </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">min_edge</span><span style="color: #C9D1D9">[k];</span></span>
<span class="line"><span style="color: #C9D1D9">                        }</span></span>
<span class="line"><span style="color: #C9D1D9">                    }</span></span>
<span class="line"><span style="color: #C9D1D9">                }</span></span>
<span class="line"><span style="color: #C9D1D9">            }</span></span>
<span class="line"><span style="color: #C9D1D9">        }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #8B949E">// 将新的节点加入生成树</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FFA657">in_mst</span><span style="color: #C9D1D9">[new_node] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #8B949E">// 输出新加入的边</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #D2A8FF">printf</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">"(</span><span style="color: #79C0FF">%d</span><span style="color: #A5D6FF">, </span><span style="color: #79C0FF">%d</span><span style="color: #A5D6FF">) </span><span style="color: #79C0FF">%d\n</span><span style="color: #A5D6FF">"</span><span style="color: #C9D1D9">, old_node, new_node, min_weight);</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">main</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// 生成一个随机图</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> n </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">10</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> m </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">20</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">graph</span><span style="color: #C9D1D9">[MAX_VERTICES][MAX_VERTICES];</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">memset</span><span style="color: #C9D1D9">(graph, </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">sizeof</span><span style="color: #C9D1D9">(graph));</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">struct</span><span style="color: #C9D1D9"> edge </span><span style="color: #FFA657">edges</span><span style="color: #C9D1D9">[MAX_EDGES];</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> count </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> (</span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> i </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">; i </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> n; i</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> (</span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> j </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> i </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">; j </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> n; j</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (</span><span style="color: #D2A8FF">rand</span><span style="color: #C9D1D9">() </span><span style="color: #FF7B72">%</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">2</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">graph</span><span style="color: #C9D1D9">[i][j] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">rand</span><span style="color: #C9D1D9">() </span><span style="color: #FF7B72">%</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">100</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">graph</span><span style="color: #C9D1D9">[j][i] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">graph</span><span style="color: #C9D1D9">[i][j];</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">edges</span><span style="color: #C9D1D9">[count].src </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> i;</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">edges</span><span style="color: #C9D1D9">[count].dest </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> j;</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">edges</span><span style="color: #C9D1D9">[count].weight </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">graph</span><span style="color: #C9D1D9">[i][j];</span></span>
<span class="line"><span style="color: #C9D1D9">                count</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">            }</span></span>
<span class="line"><span style="color: #C9D1D9">        }</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">printf</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">"Kruskal Algorithm:</span><span style="color: #79C0FF">\n</span><span style="color: #A5D6FF">"</span><span style="color: #C9D1D9">);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">kruskal</span><span style="color: #C9D1D9">(edges, n, count);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">printf</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">"</span><span style="color: #79C0FF">\n</span><span style="color: #A5D6FF">Prim Algorithm:</span><span style="color: #79C0FF">\n</span><span style="color: #A5D6FF">"</span><span style="color: #C9D1D9">);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">prim</span><span style="color: #C9D1D9">(graph, n);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>
<p>可以使用下面的命令编译并运行程序：</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">gcc mst.c -o mst</span></span>
<span class="line"><span style="color: #C9D1D9">./mst</span></span></code></pre>
<h2 id="user-9">user:</h2>
<p>冒泡排序</p>
<h2 id="assistant-9">assistant:</h2>
<p>冒泡排序（Bubble Sort）是一种基础的排序算法，其基本思想是通过不断地交换相邻的未按顺序排列的元素来达到排序的目的。</p>
<p>具体操作时，从序列的起始位置开始，对相邻的两个元素进行比较，如果顺序不对，则将它们交换。然后继续对下面一对相邻的元素进行比较，直到到达序列的结尾。这样一次遍历后，最大的元素就被移到了序列的结尾。然后再从序列的起始位置开始进行下一次遍历，但这次不需要比较已经排序好的元素。重复这个过程，直到整个序列都被排好序。</p>
<p>下面是冒泡排序的C语言实现示例：</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">#include</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#x3C;stdio.h></span></span>
<span class="line"><span style="color: #FF7B72">#include</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#x3C;stdlib.h></span></span>
<span class="line"><span style="color: #FF7B72">#include</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#x3C;time.h></span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">void</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">bubble_sort</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">arr</span><span style="color: #FF7B72">[]</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">n</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> (</span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> i </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">; i </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> n </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">; i</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> flag </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> (</span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> j </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">; j </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> n </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> i </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">; j</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (</span><span style="color: #FFA657">arr</span><span style="color: #C9D1D9">[j] </span><span style="color: #FF7B72">></span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">arr</span><span style="color: #C9D1D9">[j </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">]) {</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> temp </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">arr</span><span style="color: #C9D1D9">[j];</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">arr</span><span style="color: #C9D1D9">[j] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">arr</span><span style="color: #C9D1D9">[j </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">];</span></span>
<span class="line"><span style="color: #C9D1D9">                </span><span style="color: #FFA657">arr</span><span style="color: #C9D1D9">[j </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> temp;</span></span>
<span class="line"><span style="color: #C9D1D9">                flag </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">            }</span></span>
<span class="line"><span style="color: #C9D1D9">        }</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #8B949E">// 如果某次遍历中没有发生交换，则说明序列已经排好序，可以结束算法</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (flag </span><span style="color: #FF7B72">==</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">break</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">main</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">arr</span><span style="color: #C9D1D9">[</span><span style="color: #79C0FF">10000</span><span style="color: #C9D1D9">];</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">srand</span><span style="color: #C9D1D9">(</span><span style="color: #D2A8FF">time</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">));</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> (</span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> i </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">; i </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">10000</span><span style="color: #C9D1D9">; i</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FFA657">arr</span><span style="color: #C9D1D9">[i] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">rand</span><span style="color: #C9D1D9">() </span><span style="color: #FF7B72">%</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">100000</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> n </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">sizeof</span><span style="color: #C9D1D9">(arr) </span><span style="color: #FF7B72">/</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">sizeof</span><span style="color: #C9D1D9">(</span><span style="color: #FFA657">arr</span><span style="color: #C9D1D9">[</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">]);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">clock_t</span><span style="color: #C9D1D9"> start </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">clock</span><span style="color: #C9D1D9">();</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">bubble_sort</span><span style="color: #C9D1D9">(arr, n);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">clock_t</span><span style="color: #C9D1D9"> end </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">clock</span><span style="color: #C9D1D9">();</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">printf</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">"排序时间为：</span><span style="color: #79C0FF">%lf</span><span style="color: #A5D6FF">秒</span><span style="color: #79C0FF">\n</span><span style="color: #A5D6FF">"</span><span style="color: #C9D1D9">, (</span><span style="color: #FF7B72">double</span><span style="color: #C9D1D9">)(end </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> start) </span><span style="color: #FF7B72">/</span><span style="color: #C9D1D9"> CLOCKS_PER_SEC);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>
<p>可以使用下面的命令编译并运行程序：</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">gcc bubble_sort.c -o bubble_sort</span></span>
<span class="line"><span style="color: #C9D1D9">./bubble_sort</span></span></code></pre>
<p>冒泡排序是一种时间复杂度为O(n^2)的算法，不适用于大规模数据的排序。</p>
<h2 id="user-10">user:</h2>
<p>插入排序</p>
<h2 id="assistant-10">assistant:</h2>
<p>插入排序（Insertion Sort）是一种基本的排序算法。它的基本思想是将未排好序的元素一个一个插入到已排好序的序列中，从而逐步形成有序序列。</p>
<p>具体来说，插入排序的过程就是，将待排序序列中的第一个元素当做已排好序的序列，然后从第二个元素开始遍历，将这个元素依次插入到已排好序的序列中的合适位置，直到整个序列都被排序。</p>
<p>下面是插入排序的C语言实现示例：</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">#include</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#x3C;stdio.h></span></span>
<span class="line"><span style="color: #FF7B72">#include</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#x3C;stdlib.h></span></span>
<span class="line"><span style="color: #FF7B72">#include</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#x3C;time.h></span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">void</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">insertion_sort</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">arr</span><span style="color: #FF7B72">[]</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">n</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> (</span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> i </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">; i </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> n; i</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> j </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> i;</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">while</span><span style="color: #C9D1D9"> (j </span><span style="color: #FF7B72">></span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">&#x26;&#x26;</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">arr</span><span style="color: #C9D1D9">[j] </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">arr</span><span style="color: #C9D1D9">[j </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">]) {</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> temp </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">arr</span><span style="color: #C9D1D9">[j];</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FFA657">arr</span><span style="color: #C9D1D9">[j] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">arr</span><span style="color: #C9D1D9">[j </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">];</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FFA657">arr</span><span style="color: #C9D1D9">[j </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> temp;</span></span>
<span class="line"><span style="color: #C9D1D9">            j</span><span style="color: #FF7B72">--</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">        }</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">main</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">arr</span><span style="color: #C9D1D9">[</span><span style="color: #79C0FF">10000</span><span style="color: #C9D1D9">];</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">srand</span><span style="color: #C9D1D9">(</span><span style="color: #D2A8FF">time</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">));</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> (</span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> i </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">; i </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">10000</span><span style="color: #C9D1D9">; i</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FFA657">arr</span><span style="color: #C9D1D9">[i] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">rand</span><span style="color: #C9D1D9">() </span><span style="color: #FF7B72">%</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">100000</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> n </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">sizeof</span><span style="color: #C9D1D9">(arr) </span><span style="color: #FF7B72">/</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">sizeof</span><span style="color: #C9D1D9">(</span><span style="color: #FFA657">arr</span><span style="color: #C9D1D9">[</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">]);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">clock_t</span><span style="color: #C9D1D9"> start </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">clock</span><span style="color: #C9D1D9">();</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">insertion_sort</span><span style="color: #C9D1D9">(arr, n);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">clock_t</span><span style="color: #C9D1D9"> end </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">clock</span><span style="color: #C9D1D9">();</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">printf</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">"排序时间为：</span><span style="color: #79C0FF">%lf</span><span style="color: #A5D6FF">秒</span><span style="color: #79C0FF">\n</span><span style="color: #A5D6FF">"</span><span style="color: #C9D1D9">, (</span><span style="color: #FF7B72">double</span><span style="color: #C9D1D9">)(end </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> start) </span><span style="color: #FF7B72">/</span><span style="color: #C9D1D9"> CLOCKS_PER_SEC);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>
<p>可以使用下面的命令编译并运行程序：</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">gcc insertion_sort.c -o insertion_sort</span></span>
<span class="line"><span style="color: #C9D1D9">./insertion_sort</span></span></code></pre>
<p>插入排序的时间复杂度也是O(n^2)，虽然在实际排序中可能比冒泡排序快，但仍然不适合大规模数据的排序。</p>
<h2 id="user-11">user:</h2>
<p>哈希排序</p>
<h2 id="assistant-11">assistant:</h2>
<p>哈希排序（Hash Sort）是一种通过哈希函数来对元素进行排序的算法，其基本思想是将元素映射到桶中，并在桶内使用其他排序算法来对桶内元素进行排序，最终将桶内排好序的元素取出合并成有序序列。</p>
<p>具体来说，哈希排序的过程如下：</p>
<ol>
<li>创建一个具有m个桶的哈希表，并定义一个哈希函数H，将待排序序列中的元素映射到不同的桶中。</li>
<li>对每个桶内的元素进行排序，可以使用插入排序、快速排序等其他排序算法。</li>
<li>将每个桶内排好序的元素取出合并成有序序列。</li>
</ol>
<p>在哈希排序中，哈希函数的设计至关重要，它决定了元素的映射规则和桶的个数，直接影响了排序的效率和稳定性。</p>
<p>下面是哈希排序的C语言实现示例，使用桶的个数为10，哈希函数H(x) = x%10，桶内使用插入排序对元素进行排序。</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">#include</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#x3C;stdio.h></span></span>
<span class="line"><span style="color: #FF7B72">#include</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#x3C;stdlib.h></span></span>
<span class="line"><span style="color: #FF7B72">#include</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#x3C;time.h></span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">void</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">insertion_sort</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">arr</span><span style="color: #FF7B72">[]</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">n</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> (</span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> i </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">; i </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> n; i</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> j </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> i;</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">while</span><span style="color: #C9D1D9"> (j </span><span style="color: #FF7B72">></span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">&#x26;&#x26;</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">arr</span><span style="color: #C9D1D9">[j] </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">arr</span><span style="color: #C9D1D9">[j </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">]) {</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> temp </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">arr</span><span style="color: #C9D1D9">[j];</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FFA657">arr</span><span style="color: #C9D1D9">[j] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">arr</span><span style="color: #C9D1D9">[j </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">];</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FFA657">arr</span><span style="color: #C9D1D9">[j </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> temp;</span></span>
<span class="line"><span style="color: #C9D1D9">            j</span><span style="color: #FF7B72">--</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">        }</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">void</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">hash_sort</span><span style="color: #C9D1D9">(</span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">arr</span><span style="color: #FF7B72">[]</span><span style="color: #C9D1D9">, </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">n</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">buckets</span><span style="color: #C9D1D9">[</span><span style="color: #79C0FF">10</span><span style="color: #C9D1D9">][n];</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">indices</span><span style="color: #C9D1D9">[</span><span style="color: #79C0FF">10</span><span style="color: #C9D1D9">] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> {</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">};</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// 将元素分配到桶中</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> (</span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> i </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">; i </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> n; i</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> bucket_index </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">arr</span><span style="color: #C9D1D9">[i] </span><span style="color: #FF7B72">%</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">10</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FFA657">buckets</span><span style="color: #C9D1D9">[bucket_index][</span><span style="color: #FFA657">indices</span><span style="color: #C9D1D9">[bucket_index]] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">arr</span><span style="color: #C9D1D9">[i];</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FFA657">indices</span><span style="color: #C9D1D9">[bucket_index]</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// 对每个桶内元素进行排序</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> (</span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> i </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">; i </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">10</span><span style="color: #C9D1D9">; i</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">if</span><span style="color: #C9D1D9"> (</span><span style="color: #FFA657">indices</span><span style="color: #C9D1D9">[i] </span><span style="color: #FF7B72">></span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #D2A8FF">insertion_sort</span><span style="color: #C9D1D9">(</span><span style="color: #FFA657">buckets</span><span style="color: #C9D1D9">[i], </span><span style="color: #FFA657">indices</span><span style="color: #C9D1D9">[i]);</span></span>
<span class="line"><span style="color: #C9D1D9">        }</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #8B949E">// 合并桶内有序序列</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> k </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> (</span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> i </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">; i </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">10</span><span style="color: #C9D1D9">; i</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> (</span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> j </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">; j </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">indices</span><span style="color: #C9D1D9">[i]; j</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">) {</span></span>
<span class="line"><span style="color: #C9D1D9">            </span><span style="color: #FFA657">arr</span><span style="color: #C9D1D9">[k] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">buckets</span><span style="color: #C9D1D9">[i][j];</span></span>
<span class="line"><span style="color: #C9D1D9">            k</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">        }</span></span>
<span class="line"><span style="color: #C9D1D9">    }</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">main</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #FFA657">arr</span><span style="color: #C9D1D9">[</span><span style="color: #79C0FF">10000</span><span style="color: #C9D1D9">];</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">srand</span><span style="color: #C9D1D9">(</span><span style="color: #D2A8FF">time</span><span style="color: #C9D1D9">(</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">));</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">for</span><span style="color: #C9D1D9"> (</span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> i </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">; i </span><span style="color: #FF7B72">&#x3C;</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">10000</span><span style="color: #C9D1D9">; i</span><span style="color: #FF7B72">++</span><span style="color: #C9D1D9">)</span></span>
<span class="line"><span style="color: #C9D1D9">        </span><span style="color: #FFA657">arr</span><span style="color: #C9D1D9">[i] </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">rand</span><span style="color: #C9D1D9">() </span><span style="color: #FF7B72">%</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">100000</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">+</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">1</span><span style="color: #C9D1D9">;</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> n </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">sizeof</span><span style="color: #C9D1D9">(arr) </span><span style="color: #FF7B72">/</span><span style="color: #C9D1D9"> </span><span style="color: #FF7B72">sizeof</span><span style="color: #C9D1D9">(</span><span style="color: #FFA657">arr</span><span style="color: #C9D1D9">[</span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">]);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">clock_t</span><span style="color: #C9D1D9"> start </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">clock</span><span style="color: #C9D1D9">();</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">hash_sort</span><span style="color: #C9D1D9">(arr, n);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">clock_t</span><span style="color: #C9D1D9"> end </span><span style="color: #FF7B72">=</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">clock</span><span style="color: #C9D1D9">();</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">printf</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">"排序时间为：</span><span style="color: #79C0FF">%lf</span><span style="color: #A5D6FF">秒</span><span style="color: #79C0FF">\n</span><span style="color: #A5D6FF">"</span><span style="color: #C9D1D9">, (</span><span style="color: #FF7B72">double</span><span style="color: #C9D1D9">)(end </span><span style="color: #FF7B72">-</span><span style="color: #C9D1D9"> start) </span><span style="color: #FF7B72">/</span><span style="color: #C9D1D9"> CLOCKS_PER_SEC);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>
<p>可以使用下面的命令编译并运行程序：</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">gcc hash_sort.c -o hash_sort</span></span>
<span class="line"><span style="color: #C9D1D9">./hash_sort</span></span></code></pre>
<p>相对于冒泡排序和插入排序，哈希排序的时间复杂度是O(n)，随着桶的个数m的增加，算法效率将逐渐提高。但哈希函数的设计和实现对排序效率至关重要，如果设计得不合理，甚至可能比冒泡排序和插入排序效率更低。因此，在实际应用中，需要根据具体问题进行合理的选择和设计。</p>
<h2 id="user-12">user:</h2>
<p>C语言操作大数字</p>
<h2 id="assistant-12">assistant:</h2>
<p>在C语言中，如果需要进行大数字的计算，即超过了C语言内置类型能表示的范围，可以使用以下两种库来实现：</p>
<ol>
<li>
<p>GMP库（GNU Multiple Precision Arithmetic Library）：是GNU开发组提供的一个用于进行任意精度计算的库，支持整数、有理数和浮点数的运算。GMP库提供了高效的算法和数据结构，可以非常方便地实现大数字的加、减、乘、除等计算。可以在<a href="https://gmplib.org/%E4%B8%8B%E8%BD%BD%E5%92%8C%E4%BD%BF%E7%94%A8%E3%80%82">https://gmplib.org/下载和使用。</a></p>
</li>
<li>
<p>OpenSSL库：是一个开源的渐进式加密库，支持许多加密算法和协议，包括大数字运算。与GMP库相比，OpenSSL库提供的大数字计算函数更少，但是可以与加密算法和协议进行结合使用，具有更广泛的应用场景。可以在<a href="https://www.openssl.org/%E4%B8%8B%E8%BD%BD%E5%92%8C%E4%BD%BF%E7%94%A8%E3%80%82">https://www.openssl.org/下载和使用。</a></p>
</li>
</ol>
<p>下面是一个使用GMP库实现计算1000的阶乘的示例：</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #FF7B72">#include</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#x3C;stdio.h></span></span>
<span class="line"><span style="color: #FF7B72">#include</span><span style="color: #C9D1D9"> </span><span style="color: #A5D6FF">&#x3C;gmp.h></span></span>
<span class="line"></span>
<span class="line"><span style="color: #FF7B72">int</span><span style="color: #C9D1D9"> </span><span style="color: #D2A8FF">main</span><span style="color: #C9D1D9">() {</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #79C0FF">mpz_t</span><span style="color: #C9D1D9"> n, result;</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">mpz_init</span><span style="color: #C9D1D9">(n);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">mpz_init</span><span style="color: #C9D1D9">(result);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">mpz_set_ui</span><span style="color: #C9D1D9">(n, </span><span style="color: #79C0FF">1000</span><span style="color: #C9D1D9">);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">mpz_fac_ui</span><span style="color: #C9D1D9">(result, </span><span style="color: #D2A8FF">mpz_get_ui</span><span style="color: #C9D1D9">(n));</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">gmp_printf</span><span style="color: #C9D1D9">(</span><span style="color: #A5D6FF">"1000! = </span><span style="color: #FFA198">%</span><span style="color: #A5D6FF">Zd</span><span style="color: #79C0FF">\n</span><span style="color: #A5D6FF">"</span><span style="color: #C9D1D9">, result);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">mpz_clear</span><span style="color: #C9D1D9">(n);</span></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #D2A8FF">mpz_clear</span><span style="color: #C9D1D9">(result);</span></span>
<span class="line"></span>
<span class="line"><span style="color: #C9D1D9">    </span><span style="color: #FF7B72">return</span><span style="color: #C9D1D9"> </span><span style="color: #79C0FF">0</span><span style="color: #C9D1D9">;</span></span>
<span class="line"><span style="color: #C9D1D9">}</span></span></code></pre>
<p>可以使用下面的命令编译并运行该程序：</p>
<pre is:raw="" class="astro-code" style="background-color: #0d1117; overflow-x: auto;"><code><span class="line"><span style="color: #C9D1D9">gcc -o big_number big_number.c -lgmp</span></span>
<span class="line"><span style="color: #C9D1D9">./big_number</span></span></code></pre>
<p>其中，-lgmp选项用于链接GMP库，确保程序能够正常运行。</p>
<p>以上是使用GMP库来处理大数字的示例。如果想要使用OpenSSL库，则可以在链入libcrypto库（-lcrypto）的情况下，使用BIGNUM结构体来处理大数字。需要注意的是，OpenSSL库并不是纯粹用于处理大数字运算的库，往往涉及到加密、解密等复杂工作，不建议直接使用此库进行大数字计算。</p>
<h2 id="user-13">user:</h2>
<p>http服务器开发需要考虑那些因素</p>
<h2 id="assistant-13">assistant:</h2>
<p>在开发HTTP服务器时，需要考虑以下因素：</p>
<ol>
<li>
<p>协议版本：HTTP有多个版本，如HTTP/1.0、HTTP/1.1和HTTP/2等。不同版本的协议有不同的特性和限制，因此需要根据实际情况选择合适的版本。</p>
</li>
<li>
<p>请求解析：HTTP请求包括请求方法、请求URI、协议版本、请求头和请求体等内容，需要对请求进行解析、验证和处理，确保请求合法并能够正确处理。</p>
</li>
<li>
<p>路由处理：HTTP服务器需要根据请求URI来选择处理逻辑，可以根据正则表达式或特定规则进行路由匹配和处理。</p>
</li>
<li>
<p>静态文件处理：HTTP服务器需要能够处理静态文件请求，即直接读取文件内容并发送给客户端。</p>
</li>
<li>
<p>动态请求处理：HTTP服务器需要能够识别动态请求，如CGI程序、PHP、Ruby、Node.js等，根据请求内容进行处理并返回结果给客户端。</p>
</li>
<li>
<p>请求响应：HTTP服务器需要能够正确生成响应头和响应体，并发送给客户端，确保客户端可以正确解析和显示响应结果。</p>
</li>
<li>
<p>并发处理：HTTP服务器需要考虑并发请求处理的问题，采用多线程、多进程、异步等方式来提高并发处理能力和性能。</p>
</li>
<li>
<p>安全性和稳定性：HTTP服务器需要考虑安全性和稳定性，如有效防止各种类型的攻击，如DDoS攻击、SQL注入、XSS攻击等，并对异常情况进行良好的处理和恢复机制。</p>
</li>
<li>
<p>日志记录：HTTP服务器应该能够记录访问日志和错误日志，便于管理和监控。</p>
</li>
<li>
<p>性能优化：HTTP服务器需要考虑性能优化，如使用缓存、压缩数据、优化算法等方式来提高服务器的性能和响应速度。</p>
</li>
</ol>
<p>以上是HTTP服务器开发时需要考虑的主要因素，开发者需要根据具体的场景和需求来实现并优化相应的功能。</p>
<h2 id="user-14">user:</h2>
<p>HTTP 1.0和2.0之间的区别</p>
<h2 id="assistant-14">assistant:</h2>
<p>HTTP/2与HTTP/1.0和HTTP/1.1相比有以下主要区别：</p>
<p>1.二进制协议：HTTP/2采用二进制协议，而HTTP/1.x是基于文本的协议。由于二进制协议具有更快的解析速度和更低的错误率，因此HTTP/2具有更高的性能和效率。</p>
<ol start="2">
<li>
<p>多路复用：HTTP/2采用多路复用，允许多个请求和响应同时交换，而HTTP/1.x采用序列化请求和响应，导致单向队列的阻塞问题。多路复用使得HTTP/2能够更有效地利用底层TCP连接，提高了性能。</p>
</li>
<li>
<p>首部压缩：HTTP/2引入了首部压缩算法，减少了请求和响应的首部大小，节约了带宽和传输时间。</p>
</li>
<li>
<p>服务器推送：HTTP/2支持服务器推送，即服务器可以在处理客户端请求时主动将相关资源推送给客户端，而HTTP/1.x则需要客户端发起请求才能获取相应的资源。服务器推送可以减少客户端等待时间，提高性能。</p>
</li>
</ol>
<p>除了上述主要区别，HTTP/2还引入了流、优先级和帧的概念，这些特性使得HTTP/2具有更好的性能、效率和扩展性。</p>
<p>总体来说，HTTP/2在性能、效率和协议特性等方面都比HTTP/1.x更具优势。但需要注意的是，HTTP/2需要依赖于现代浏览器和服务器，而老旧的浏览器和服务器可能无法支持HTTP/2。</p>
<h2 id="user-15">user:</h2>
<p>讲解一下HTTP/2.0的流</p>
<h2 id="assistant-15">assistant:</h2>
<p>HTTP/2.0流是指在一个TCP连接中交错发送的二进制帧序列，其中每个流代表一个逻辑完整的请求或响应。HTTP/2.0流的特点如下：</p>
<ol>
<li>
<p>同一TCP连接可以同时有多个流在交错发送和接收，一个流对应一个独立的请求或响应。</p>
</li>
<li>
<p>流之间是独立的，互不干扰。同一个TCP连接的多个流之间可以交替发送数据帧，不需要等待前一个流发送完成。</p>
</li>
<li>
<p>流可以有自己的优先级，即每个流可以被赋予优先级，以保证重要数据的传输优先级高于次要数据。</p>
</li>
<li>
<p>流可以被关闭，以便在单个TCP连接上进行多个请求和响应。</p>
</li>
</ol>
<p>流的建立遵循了HTTP/2.0协议，即在客户端和服务端之间建立连接后，建立HTTP流时，客户端必须首先发送一个HEADERS frame，来携带HTTP请求信息，然后服务端会回复一个HEADERS frame，携带HTTP响应信息。请求和响应中的所有数据都通过DATA frames交换，而结束一个流则需要使用RST_STREAM帧。</p>
<p>HTTP/2.0流的特性使得多个请求可以同时在一个TCP连接上进行，减少了建立多个TCP连接的时间和连接开销，提高了传输效率。同时，流的优先级和独立性可以帮助开发者更好地管理HTTP请求和响应，提高传输质量和用户体验。</p>
<h2 id="user-16">user:</h2>
<p>优先级</p>
<h2 id="assistant-16">assistant:</h2>
<p>HTTP/2.0引入了流的优先级概念，使得客户端可以明确地告诉服务器它希望哪些资源优先获取，从而提高用户体验和网站性能。</p>
<p>HTTP/2.0中的流采用二进制帧的形式进行传输，其中每个流都有自己的唯一标识符和优先级。优先级是通过4个字节的值来表示的，范围从0-2^31-1，其中数值越小的流优先级越高。</p>
<p>当多个流同时请求数据时，服务器可以根据这些流的优先级来确定哪些应该先返回，从而提高整体响应速度。当然，客户端也可以根据自己的需要调整流的优先级来实现资源的更精确获取。</p>
<p>在HTTP/2.0中，流的优先级是基于父流和子流之间的关系来确定的。每个流可以有多个子流，而每个子流可以有自己的子流，形成了多个层级。优先级的权值随着层级的加深而不断减小，从而确保优先级更高的流可以先被处理。</p>
<p>总体来说，HTTP/2.0中的优先级机制可以帮助开发者更好地管理和优化HTTP请求和响应的传输顺序，提高网站的性能和用户体验。</p>
<h2 id="user-17">user:</h2>
<p>帧</p>
<h2 id="assistant-17">assistant:</h2>
<p>在HTTP/2.0协议中，所有的客户端和服务器之间的数据传输都是通过帧（frame）的方式进行的。HTTP/2.0中定义了14种不同类型的帧，每种帧对应着不同的协议控制消息和数据类型。</p>
<p>HTTP/2.0的帧结构如下：</p>
<ul>
<li>帧头部（Frame Header）
<ul>
<li>有效载荷长度(Payload Length)</li>
<li>类型（Type）</li>
<li>标志（Flags）</li>
<li>流标识符（Stream Identifier）</li>
</ul>
</li>
<li>帧有效载荷（Frame Payload）</li>
</ul>
<p>其中，有效载荷长度指的是整个帧的长度，包括帧头部和有效载荷；类型指的是当前帧所表示的类型，控制帧有9种类型，数据帧有1种类型；标志位则在不同的帧类型中有不同的含义，用于指示当前帧是否有特定的特征；流标识符则用于标识当前帧所归属的流。</p>
<p>HTTP/2.0的帧类型包括：</p>
<ul>
<li>DATA: 用于传输HTTP请求和响应的数据，包括HTTP报文体和数据流的终止标志。</li>
<li>HEADERS: 用于传输HTTP请求和响应的首部信息。</li>
<li>PRIORITY: 用于确定HTTP请求的优先级。</li>
<li>RST_STREAM: 用于告知对方一个流被重置了，无法再继续处理。</li>
<li>SETTINGS: 用于传输客户端和服务器之间的连接级别的配置信息。</li>
<li>PUSH_PROMISE: 用于在服务器推送资源时向客户端发送响应流的信息。</li>
<li>PING: 用于测量HTTP/2.0连接的延迟和确认连接的存活状态。</li>
<li>GOAWAY: 用于告知对方连接即将关闭。</li>
<li>WINDOW_UPDATE: 用于调整窗口大小，控制整个流量控制的速度。</li>
<li>CONTINUATION: 用于传输超过一个帧长度的首部块。</li>
</ul>
<p>通过使用不同类型的帧，HTTP/2.0可以更加灵活地进行数据传输和控制，提高传输效率和性能。</p>
<h2 id="user-18">user:</h2>
<p>开发中如何使用这些东西</p>
<h2 id="assistant-18">assistant:</h2>
<p>在开发中，我们可以使用HTTP/2.0协议的优化功能来提高网站的性能和用户体验。下面是几种使用HTTP/2.0的方法：</p>
<ol>
<li>
<p>将网站升级到HTTPS协议：HTTP/2.0协议要求网站必须使用HTTPS协议才能生效，因此我们需要将网站升级到HTTPS协议，可以使用Let’s Encrypt等免费证书实现。</p>
</li>
<li>
<p>使用服务器和客户端支持HTTP/2.0的软件和工具：HTTP/2.0需要服务器和客户端都支持才能生效，因此我们需要使用支持HTTP/2.0协议的服务器软件，如Nginx或Apache等。同时，我们需要确保客户端浏览器支持HTTP/2.0协议，目前市场上的主流浏览器均已支持HTTP/2.0协议，如Chrome、Firefox、Safari等。</p>
</li>
<li>
<p>使用性能优化工具：HTTP/2.0协议提供了多路复用和头部压缩等功能，可以减少连接的延迟，提高数据传输效率。同时，我们也可以使用性能优化工具，如CDN、缓存等，加速网站响应。</p>
</li>
<li>
<p>使用流的优先级：使用流的优先级可以让客户端明确告知服务器哪些资源需要优先获取，提高页面加载速度和用户体验。</p>
</li>
<li>
<p>精简和合并资源：由于HTTP/2.0支持多路复用，可以同时传输多个请求和响应，因此我们可以将多个小资源合并成一个较大的文件，减少网络传输的延迟，提高性能。</p>
</li>
</ol>
<p>总的来说，使用HTTP/2.0协议可以提高网站的性能和用户体验，我们需要升级网站到支持HTTP/2.0的HTTPS协议，同时使用服务器和客户端支持HTTP/2.0的软件和工具，使用性能优化工具，使用流的优先级，以及精简和合并资源等方法，优化网站性能并提高用户体验。</p>
<h2 id="user-19">user:</h2>
<p>HTTP/2.0还有什么特性吗</p>
<h2 id="assistant-19">assistant:</h2>
<p>除了多路复用、头部压缩、服务器推送等特性外，HTTP/2.0还有以下几个特性：</p>
<ol>
<li>
<p>二进制分帧（Binary framing）：HTTP/2.0将HTTP1.1中的文本协议改为了二进制协议，将HTTP消息划分为更小的帧，便于传输和控制，减少了传输的时延。</p>
</li>
<li>
<p>服务器推送的优化（Server push optimizations）：HTTP/2.0中的服务器可以主动向客户端推送相关资源，避免了客户端重复请求相同的资源，提高了页面加载速度和用户体验。</p>
</li>
<li>
<p>流量控制（Flow control）：HTTP/2.0中新增了一个流量控制机制，可以在发送方和接收方之间交换窗口大小，控制流量，从而避免数据阻塞和带宽饱和现象，提高了传输性能。</p>
</li>
<li>
<p>服务器推送的取消（Server push cancellation）：HTTP/2.0中可以取消服务器推送的流，从而避免了无用数据的传输浪费，提高了传输效率。</p>
</li>
<li>
<p>帧优先级（Frame prioritization）：HTTP/2.0中引入了帧优先级概念，可以将HTTP请求和响应划分为多个流，并为每个流设置优先级，从而控制HTTP请求和响应的流量，提高了传输效率和用户体验。</p>
</li>
</ol>
<p>综上所述，HTTP/2.0协议拥有多种特性，如二进制分帧、服务器推送优化、流量控制、帧优先级等，这些特性都能有效提高HTTP协议的传输效率，改善用户体验。</p>
<h2 id="user-20">user:</h2>
<p>如何应对DDoS攻击</p>
<h2 id="assistant-20">assistant:</h2>
<p>DDoS攻击是一种常见的网络攻击手段，能够让目标网站服务过载或瘫痪，给网站运营者带来重大的经济和声誉损失。以下是一些应对DDoS攻击的方法：</p>
<ol>
<li>
<p>保持网站的安全性：对网站进行全面安全评估和测试，修补漏洞、加固访问控制等，提高网站的弹性，减少受到攻击的可能性。</p>
</li>
<li>
<p>购买DDoS防护服务：防止不良流量侵入服务器，购买专业的DDoS防护服务，或采用CDN等分布式防御服务来缓解DDoS攻击的影响。</p>
</li>
<li>
<p>升级网站服务器设备：选择高配置的服务器设备，提高带宽和处理能力，增强网站的服务能力，能够更好地应对DDoS攻击。</p>
</li>
<li>
<p>限制连接数：使用网络层或传输层设备限制连接数，限制用户的访问频率，同时阻止恶意连接，减少DDoS攻击的影响。</p>
</li>
<li>
<p>实施反向代理：使用反向代理服务器，将所有流量集中在反向代理服务器上，由反向代理服务器进行流量分发，可以起到隔离DDoS攻击流量，保护网站服务器的作用。</p>
</li>
<li>
<p>实施封堵策略：实施合理的封堵策略，对恶意IP地址进行封禁，从而防止DDoS攻击的继续发生。</p>
</li>
<li>
<p>及时备份数据：及时备份网站数据和信息，减少损失和影响，以恢复瘫痪的服务。</p>
</li>
</ol>
<p>综上所述，应对DDoS攻击需要综合考虑多种因素，包括网站安全、DDoS防护服务、服务器设备、限制连接数、反向代理、封堵策略等，可以有效减少DDoS攻击的影响和风险。</p>
<h2 id="user-21">user:</h2>
<p>如何实现限流</p>
<h2 id="assistant-21">assistant:</h2>
<p>限流是一种保护系统，防止因高峰时段流量突增而导致的系统崩溃。实现限流的主要方法有以下几种：</p>
<ol>
<li>漏桶算法</li>
</ol>
<p>漏桶算法是一种简单有效的限流算法，该算法的核心思路是：以固定的速率向外漏水，当水流入桶中时，当桶满时，溢出的水流将被丢弃。</p>
<ol start="2">
<li>令牌桶算法</li>
</ol>
<p>令牌桶算法是另一种常用的限流算法，该算法会在固定时间内生成一定数量的令牌，每次请求需要获取一个令牌并发起请求，直到令牌根据请求被用尽，此时无法发起请求直至下一周期令牌的生成。</p>
<ol start="3">
<li>计数器</li>
</ol>
<p>计数器是一种简单的限流方法，可以通过对每个请求进行计数，如果请求的数量超过了设置的阈值，则限制进一步的请求。</p>
<ol start="4">
<li>时间窗口</li>
</ol>
<p>时间窗口是一种基于时间维度的限流方法，将时间划分为若干个连续的时间窗口，每个时间窗口内设置一个请求阈值。只有当当前窗口内的请求数量不超过阈值时，客户端才能继续发送请求，否则客户端将无法发送请求。</p>
<p>综上所述，实现限流需要考虑多方面的因素，包括算法的复杂度、系统的实时性、系统的可伸缩性等。不同的场景需要选择不同的限流方案，在实际应用中，需要综合考虑多个因素，权衡设计方案的适用性、可扩展性和性能。</p>
<h2 id="user-22">user:</h2>
<p>惊群以及应对方法</p>
<h2 id="assistant-22">assistant:</h2>
<p>惊群是指在高并发的场景下，多个线程或者进程同时竞争某个资源，但只有其中一个能够获取资源成功（例如一个热点缓存），其他的线程或者进程会重新发起请求并增加系统的负载，导致系统的性能下降。下面是一些应对惊群问题的方法：</p>
<ol>
<li>优化资源访问的方式</li>
</ol>
<p>尽量避免所有线程同时去请求热点资源，可以通过队列进行请求资源的调度，解决惊群问题。</p>
<ol start="2">
<li>缓存热点资源</li>
</ol>
<p>针对热点资源，可以使用缓存服务进行预热，减少相应的请求次数，保护资源不被瞬间压垮。</p>
<ol start="3">
<li>加锁减少冲突</li>
</ol>
<p>对于某个资源只允许一个线程对其进行修改的场景，可以采用悲观锁并识别超时等异常情况，减少资源冲突的情况。</p>
<ol start="4">
<li>随机等待/睡眠</li>
</ol>
<p>在高并发的场景下，可以让请求进行随机等待或者睡眠一段时间，避免多个请求同时到来，在某一瞬间同时进行访问。</p>
<ol start="5">
<li>采用分布式锁</li>
</ol>
<p>在分布式架构中，惊群问题更为常见，可以使用分布式锁进行资源竞争的协调，保证只有一个客户端能够获得资源的访问权限，防止惊群问题的发生。</p>
<ol start="6">
<li>优化系统设计</li>
</ol>
<p>针对高并发场景，可以尝试从根本上优化系统的设计，调整系统架构、部署方案、代码实现等等，从源头上避免或者减少惊群问题的出现。</p>
<p>总之，在高并发场景下，预防和解决惊群问题不是一朝一夕就能完成的，需要深入理解系统的工作流程和资源的特点，同时根据实际情况采取合适的方法和策略。</p>
<h2 id="assistant-23">assistant:</h2>
<p>生产者消费者问题是一个经典的同步问题，主要存在于多线程和进程之间共享资源的场景中。典型的场景是多个线程并发地访问一个共享的、有固定大小的缓冲区，其中生产者向缓冲区中添加数据，而消费者则从中消费并移除数据。</p>
<p>生产者消费者问题的主要目标是实现生产者和消费者之间的协调，保证缓冲区中的数据不会出现生产者和消费者访问冲突的情况。</p>
<p>常见的解决方案有以下几种：</p>
<ol>
<li>临界区</li>
</ol>
<p>使用互斥锁或信号量等同步机制将生产者和消费者的操作加上互斥锁，在临界区内完成对于缓冲区操作的访问。但是这种方法存在性能问题，因为互斥锁会导致线程等待。</p>
<ol start="2">
<li>信号量</li>
</ol>
<p>使用两个信号量分别表示缓冲区空格和缓冲区已有数据的个数，通过信号量的操作实现生产者和消费者的共享访问。当缓冲区已满时，生产者将被阻塞；当缓冲区为空时，消费者也会被阻塞。</p>
<ol start="3">
<li>管道</li>
</ol>
<p>使用管道作为缓冲区，生产者将数据写入管道，消费者从管道中读取数据。不过，这种方法适用于进程间通信，不适用于线程间通信。</p>
<ol start="4">
<li>同步队列</li>
</ol>
<p>使用同步队列作为缓冲区，相比于其他解决方案，这种方法有更好的性能表现。生产者调用队列的添加方法，消费者从队列中取出数据，当队列已满或为空时，线程将被阻塞等待。Java 中的 BlockingQueue 就是一个同步队列的实现。</p>
<p>综上所述，不同的场景和需求需要选择不同的解决方案。针对生产者消费者问题，还需要注意防止死锁和饥饿等问题。</p>
<h2 id="assistant-24">assistant:</h2>
<p>哲学家用餐问题是一个经典的同步问题，主要是考虑多个哲学家在共享一张圆桌用餐的问题。圆桌中间有 5 个叉子，每个哲学家需要同时拿到相邻的两个叉子才能开始用餐。</p>
<p>如果每个哲学家都拿起自己左边的叉子，会导致死锁的情况。例如，假设 5 个哲学家同时拿起自己左边的叉子，而需要的右边的叉子都被旁边的哲学家占用，那么所有人都在等待，形成了死锁。</p>
<p>为了避免这种情况，可以采用以下解决方案：</p>
<ol>
<li>限制最大同时用餐数</li>
</ol>
<p>引入限制最大同时用餐人数的规则，例如设置只能有 4 个哲学家同时用餐，从而避免所有人都尝试取叉子的情况。但是这种方案可能导致资源浪费，即有的哲学家拿不到叉子却一直等待。</p>
<ol start="2">
<li>避免循环等待</li>
</ol>
<p>修改取叉子的顺序，例如要求所有哲学家必须先拿自己的左叉子，再拿自己的右叉子，这样可以避免循环等待的现象。</p>
<ol start="3">
<li>引入协调机制</li>
</ol>
<p>设置一个中央的调解者，当哲学家需要用餐时，向调解者申请叉子，调解者判断是否可以分配，当决定分配时，给相应的哲学家发送通知。这种方案可以有效地避免死锁，但是会增加额外的开销和延迟。</p>
<ol start="4">
<li>模拟抢占式分配资源</li>
</ol>
<p>哲学家在取叉子之前必须先获取一个单独的锁，判断叉子是否可用。如果叉子不可用，则哲学家将锁释放，等待一段随机时间后再重新尝试获取锁。这种方案通过模拟抢占式分配资源的过程，可以避免死锁的情况。但是这种方案需要精确控制等待时间并考虑到各种极端情况，因此比较复杂。</p>
<p>综上所述，不同的解决方案有着各自的优缺点，需要根据实际情况进行选择。</p>
<h2 id="assistant-25">assistant:</h2>
<p>土耳其将军是一个经典的递归问题。问题的背景是：有一只公鸡和一只母鸡，它们还有一窝鸡蛋。其中，公鸡有五倍于母鸡的体重，而每个鸡蛋的重量等于公鸡和母鸡体重的差。现在假设有土耳其将军来到了你家，他想要知道鸡蛋的重量，而你只能让他拿起来感受一下。因此，你需要通过一些方法，让将军确定鸡蛋的重量，但是不能让他知道公鸡和母鸡的重量是多少。</p>
<p>解决这个问题的核心思路是通过递归将问题不断分解，最终转化为一个简单的问题。具体来说，可以采用以下的解决方案：</p>
<ol>
<li>
<p>将鸡蛋重量的取值范围分成两半，分别假设为 A 和 B。</p>
</li>
<li>
<p>将一只鸡拿起来，称量它的重量 W。</p>
</li>
<li>
<p>如果 W 大于 A+B，那么鸡蛋重量一定在范围 B 中（因为公鸡的体重是母鸡的五倍，所以如果鸡的重量大于 A+B，则鸡蛋重量一定大于公鸡的重量，因此在范围 B 中）。</p>
</li>
<li>
<p>如果 W 小于 A+B，那么鸡蛋重量一定在范围 A 中。</p>
</li>
<li>
<p>如果 W 等于 A+B，那么鸡蛋重量就是 W 减去公鸡的重量。</p>
</li>
<li>
<p>对于新的范围 A 和 B，重复步骤 2-5。</p>
</li>
<li>
<p>最终得到鸡蛋的重量。</p>
</li>
</ol>
<p>这个算法就是通过递归的方式不断分解问题，将复杂的问题简化为一个读取数值的过程。通过这个算法，我们可以解决类似的问题，将一个大问题不断化为小问题，最终求得问题的解答。</p>
	</body></html>